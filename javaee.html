<!DOCTYPE html>
 <html lang="pt-br">
 <head>
   <head>
 <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" >
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="css/font-awesome/css/font-awesome.min.css">
 <link rel="stylesheet" type="text/css" href="css/stylos.css">
 <link rel="stylesheet" href="css/stylew3.css">
 <script type="text/javascript"src="js/efeitos.js"></script>
 <link rel="stylesheet" type="text/css" href="code-brush-master/tyrm.css" media="all" />
<script src="code-brush-master/cbCore.js"></script>
<script src="code-brush-master/cBrushXml.js"></script>
<script src="code-brush-master/cBrushCss.js"></script>
<script src="code-brush-master/cBrushPhp.js"></script>
<script src="code-brush-master/cBrushSql.js"></script>
<script src="code-brush-master/cBrushJScript.js"></script>   
<script src="code-brush-master/cBrushJava.js"></script>  
<script>
    SyntaxHighlighter.defaults['auto-links'] = false;
    SyntaxHighlighter.defaults['toolbar'] = false;
    SyntaxHighlighter.all();
</script>
 <title> Programar em Java</title>
 </head>
 <body>


<!-- Top Navigation Menu -->
  <div id="voltarTopo">
  <a href="#" id="subir">Topo</a>
</div>
<nav class="w3-sidebar w3-bar-block w3-collapse w3-animate-left w3-card" style="z-index:3;width:250px;" id="mySidebar">
  <!--<a class="w3-bar-item w3-button w3-border-bottom w3-large" href="#"><img src="https://www.w3schools.com/images/w3schools.png" style="width:80%;"></a>-->
  <a class="w3-bar-item w3-button w3-hide-large w3-large" href="javascript:void(0)" onclick="w3_close()">Close <i class="fa fa-remove"></i></a>
  <a class="w3-bar-item w3-button w3-teal" href="index.html">Home</a>
   <a class="w3-bar-item w3-button" href="#javaee7">19- JAVA EE 7, SERVLET, JSP </a>
          <a class="w3-bar-item w3-button" href="#pltjavee7">A Plataforma Java EE</a>
          <a class="w3-bar-item w3-button"href="#camcliente">A Camada do Cliente</a>
          <a class="w3-bar-item w3-button"href="#acamweb">A Camada Web</a>
          <a class="w3-bar-item w3-button"href="#camadweb">Camada Web</a>
          <a class="w3-bar-item w3-button"href="#dadoscamada">Camada de Acesso aos Dados</a>
          <a class="w3-bar-item w3-button" href="#frmweb">Framework Java Web</a>
          <a class="w3-bar-item w3-button"href="#intrdjava">A Introdução ao Java</a>
          <a class="w3-bar-item w3-button" href="#confambdev">Configurando o Ambiente de 

Desenvolvimento</a>
          <a class="w3-bar-item w3-button"href="#devappide">Desenvolvendo aplicações Java com uma IDE</a>
          <a class="w3-bar-item w3-button"href="#criarprojeto">Criar o primeiro Projeto no IDE</a>
          <a class="w3-bar-item w3-button"href="#criarapp">Criando uma Aplicação</a>
          <a class="w3-bar-item w3-button"href="#bookstoreapp">A Aplicação Bookstore</a>
          <a class="w3-bar-item w3-button" href="#modeldados">Aplicação para o modelo de Dados do Bookstore</a>
          <a class="w3-bar-item w3-button"href="#camdacesso">Camada de Acesso a Dados</a>

           <a class="w3-bar-item w3-button" href="#clientacess">Cliente para a camada de acesso a dados</a>
          <a class="w3-bar-item w3-button"href="#servletjsp">Construindo aplicativos da Web usando servlets e JSP</a>
          <a class="w3-bar-item w3-button"href="#servlets">Servlets</a>
          <a class="w3-bar-item w3-button"href="#sevletolamundo">Solicitar fluxo para o servlet OlaMundo</a>
          <a class="w3-bar-item w3-button"href="#examrequest">Examinando um solicitação</a>
          <a class="w3-bar-item w3-button" href="#ciclodevida">Os métodos do ciclo de vida</a>
          <a class="w3-bar-item w3-button"href="#genericserv">GenericServlet</a>
          <a class="w3-bar-item w3-button" href="#httpserv">HttpServlet</a>
          <a class="w3-bar-item w3-button"href="#sevola">Servlet OlaMundo</a>
          <a class="w3-bar-item w3-button"href="#init">Init()</a>
          <a class="w3-bar-item w3-button"href="#services">service()</a>
          <a class="w3-bar-item w3-button"href="#destroi">destroy()</a>
          <a class="w3-bar-item w3-button" href="#servconfig">ServletContext e ServletConfig</a>
          <a class="w3-bar-item w3-button"href="#parinit">Parâmetros de Inicialização</a>


          <a class="w3-bar-item w3-button" href="#paramcontext">Parametros de contexto de 
Inicialização</a>
          <a class="w3-bar-item w3-button"href="#requestdisp">RequestDispatcher</a>
          <a class="w3-bar-item w3-button"href="#requestservlet">Obtendo um RequestDipatcher de um ServletRequest</a>
          <a class="w3-bar-item w3-button"href="#restservcontext">Obtendo um RequestDispacher de um ServletContext</a>
          <a class="w3-bar-item w3-button"href="#filtros">Filter</a>
          <a class="w3-bar-item w3-button" href="#vianotation">Configurando Servlets via Anotações</a>
          <a class="w3-bar-item w3-button"href="#javaservepage">Java Server Pages</a>
          <a class="w3-bar-item w3-button" href="#firstapp">Primeiro Aplicativo</a>
          <a class="w3-bar-item w3-button"href="#jspbasic">JSP Basico</a>
          <a class="w3-bar-item w3-button"href="#directivejsp">JSP Directives</a>
          <a class="w3-bar-item w3-button"href="#pagedirective">Page Directive</a>
          <a class="w3-bar-item w3-button"href="#includejsp">Include Directive</a>
          <a class="w3-bar-item w3-button" href="#taglibdir">TagLib Directive</a>
          <a class="w3-bar-item w3-button"href="#declaracoes">Declarações</a>

           <a class="w3-bar-item w3-button" href="#expressao">Expressão</a>
          <a class="w3-bar-item w3-button"href="#scriptlet">Scriptlets</a>
          <a class="w3-bar-item w3-button"href="#objimplicito">Objetos Implicito</a>
          <a class="w3-bar-item w3-button"href="#appbook">Aplicativo</a>
          <a class="w3-bar-item w3-button"href="#config">config</a>
          <a class="w3-bar-item w3-button" href="#exception">exception</a>
          <a class="w3-bar-item w3-button"href="#out">out</a>
          <a class="w3-bar-item w3-button" href="#page">page</a>
          <a class="w3-bar-item w3-button"href="#pagecontext">pageContext</a>
          <a class="w3-bar-item w3-button"href="#requests">request</a>
          <a class="w3-bar-item w3-button"href="#response">response</a>
          <a class="w3-bar-item w3-button"href="#session">session</a>
          <a class="w3-bar-item w3-button" href="#actionpd">Ações padrão</a>
          <a class="w3-bar-item w3-button"href="#actioninclude">A acão &ltjsp:Include ></a>
  
  
            <a class="w3-bar-item w3-button"href="#actionsgeral">As Ações &ltjsp:useBean>, &ltjsp:getProperty>, e &ltjsp:setProperty</a>
          <a class="w3-bar-item w3-button" href="#padraomvc">O Padrão MVC</a>
          <a class="w3-bar-item w3-button"href="#bookstoreapps">Aplicativo BookStore</a>
          <a class="w3-bar-item w3-button"href="#pginit">A Página Inicial</a>
          <a class="w3-bar-item w3-button"href="#etapaum">Etapa 1: Localizando o Servlet a partir da Solicitação</a>

          <a class="w3-bar-item w3-button"href="#etapa2e3">Etapa 2 e Etapa 3: Acessando o banco de dados via DAO para obter as categorias do banco de dados e definindo as categorias no modelo.</a>
          <a class="w3-bar-item w3-button" href="#etapaquatro">Etapa 4: Despachando para a 
visulização</a>
          <a class="w3-bar-item w3-button"href="#etapa5">Etapa 5: Acessando o modelo da 
visualização</a>
          <a class="w3-bar-item w3-button"href="#etapa6">Etapa 6: Enviando a Resposta</a>
          <a class="w3-bar-item w3-button"href="#pesquisarlivro">Pesquisando Livros por Categoria</a>
          <a class="w3-bar-item w3-button"href="#pesporchave">Pesquisando os Livros por Palavra Chave</a>
  <div>
    <a class="w3-bar-item w3-button" onclick="myAccordion('demo')" href="javascript:void(0)">Mapa de Links <i class="fa fa-caret-down"></i></a>
    <div id="demo" class="w3-hide">

     
<a class="w3-bar-item w3-button" href= "estruturadojava.html">1 - A Estrutura do Java</a>
     <a class="w3-bar-item w3-button" href="operadorjava.html">2 - Operadores em java</a>

<a class="w3-bar-item w3-button" href="apijava.html">3 - APIs Java</a>
<a class="w3-bar-item w3-button" href=" metodoenc.html">4 - Métodos e Encapsulamento</a>

<a class="w3-bar-item w3-button" href="designdeclasse.html">5 - Design de Classe </a>
<a class="w3-bar-item w3-button" href="excecao.html">6 - Exceções</a>

<a class="w3-bar-item w3-button" href="designavancado.html">7 - Design de Classe I</a>

<a class="w3-bar-item w3-button" href="designdeclasseavancado.html">8 - Design de Classe Avançado</a>
<a class="w3-bar-item w3-button" href=" colecaogeneric.html">9 - Generics E Collection</a>
<a class="w3-bar-item w3-button" href="lambda.html">10 - Interfaces Funcionais embutidas do Lambda </a>

<a class="w3-bar-item w3-button" href="apistream.html">11- Java Stream API</a>
<a class="w3-bar-item w3-button" href="exceptioassertion.html">12 - Exceções Asserçoes</a>

<a class="w3-bar-item w3-button" href="datetime.html">13 - Usando API DateTime JSE8</a>
<a class="w3-bar-item w3-button" href=" javaio.html">14 - Java IO Fundamental</a>
<a class="w3-bar-item w3-button" href="javafilenio.html">15 - Java File I/O (NIO.2) </a>
<a class="w3-bar-item w3-button" href="concorrenciajava.html">16 - Concorrência com Java</a>
<a class="w3-bar-item w3-button" href="jdbcaplication.html">17 - Construindo aplicações Com Banco de Dados JDBC</a>

<a class="w3-bar-item w3-button" href="localization.html">18 - Localização</a>
<a class="w3-bar-item w3-button" href="mlpraticasjee.html">20 - Práticas recomendada Java EE web </a>

<a class="w3-bar-item w3-button" href="padroes.html">21 - Soluções prática usando Padrões</a>
<a class="w3-bar-item w3-button" href="webstrut.html">22 - Iniciando Aplicativo web com Struts2</a>
<a class="w3-bar-item w3-button" href="appbook.html">23- Construindo Aplicativo Bookstore web com Struts2</a>
<a class="w3-bar-item w3-button" href= "springmvc.html">24 - Construindo Aplicativos Web  com o Spring Web MVC</a>
<a class="w3-bar-item w3-button" href= "springwebmvc.html">25 - Criando aplicativos da Web com o Spring Web MVC</a>

<a class="w3-bar-item w3-button" href= "springboot.html">26 - Atualização dos serviços com Spring Boot</a>
      
    </div>
  </div>
</nav>

<div class="w3-overlay w3-hide-large w3-animate-opacity" onclick="w3_close()" style="cursor:pointer" id="myOverlay"></div>

<div class="w3-main" style="margin-left:250px;">

<div id="myTop" class=" w3-top w3-large">
  <p><i class="fa fa-bars w3-button w3-teal w3-hide-large w3-xlarge" onclick="w3_open()"></i>
</p>
</div>
<header class="w3-container w3-theme" style="padding:64px 32px">
  <h1 class="w3-xxxlarge">JAVA EE 7, SERVLET, JSP </h1>
</header>
<section id="javaee7">
<h1>Java EE 7</h1>
<p>O Java começou a vida como uma linguagem de programação projetada para criar aplicativos independentes e cresceu rapidamente em outras esferas. Uma grande parte da popularidade do Java pode ser atribuída ao seu uso na criação
Aplicativos da web. Um aplicativo da Web consiste em páginas da Web estáticas e dinâmicas (interativas). As páginas da Web estáticas contêm vários tipos de linguagens de marcação (HTML, XHTML e assim por diante) e são usadas, em geral, para fornecer informações; As páginas dinâmica da web, por outro lado, são capazes de gerar conteúdo com o auxílio de componentes adicionais da web. Assim, um aplicativo da web é uma coleção de páginas da web e é capaz de gerar conteúdo dinâmico em resposta a solicitações.</p>
<p>Ao contrário de uma página da Web usada apenas para fornecer informações, um aplicativo da Web permite executar alguma atividade e salvar o resultado. O desenvolvimento de um aplicativo da Web, no entanto, é fundamentalmente diferente da criação de aplicativos independentes e exige que você entenda os três elementos principais a seguir:</p>
<br>
<ul>
<li><b>A plataforma Java EE</b>: Esse é o conjunto de especificações da API que são os blocos de construção do aplicativo da web.</li>
<li><b>O contêiner da web</b>: o contêiner da web implementa as especificações da API da plataforma Java EE. Especificamente, o contêiner da Web fornece os serviços para gerenciar e executar componentes da web, como servlets, JSPs, filtros, listeners e respostas de renderização para o cliente</li>
</ul>
<br>
</section>
<section id="pltjavee7">
<h2>A Plataforma Java EE</h2>
<p>A plataforma Java EE é orientada pelos dois objetivos a seguir:</p>
<ul>
<li>Fornecer as especificações da API que são os blocos de construção do aplicativo Web.</li>
<li>Padronizar e reduzir a complexidade do aplicativo corporativo em desenvolvimento. Ele faz isso fornecendo um modelo de aplicativo que define uma arquitetura para implementar serviços como aplicativos de várias camada</li>
</ul>
<br>
<p>A plataforma Java EE visa padronizar e reduzir a complexidade do desenvolvimento de aplicativos corporativos, fornecendo um modelo de aplicativo que define uma arquitetura para implementar
serviços como aplicativos de várias camadas. Em um aplicativo de várias camadas, a funcionalidade do aplicativo é separada em áreas funcionais distintas, chamadas de camadas. </p>
<br>
<img src="imagens\jee7\multiplaarqutetura.jpg">

<p><i>Múltipla arquitetura no Java</i></p>
<br>
</section>
<section id="camcliente">
<h4>A Camada do Cliente</h4>

<p>A camada do cliente é a camada superior em uma arquitetura Java EE de várias camadas; consiste em clientes de aplicativos que fazem solicitações ao servidor Java EE, que geralmente está localizado em uma máquina diferente. O servidor processa as solicitações e retorna uma resposta ao cliente. Um exemplo de cliente é um navegador da Web ou um aplicativo independente.</p>
</section>
<sectionid id="acamweb">
<h4>A Camada Web</h4>

<p>A camada da web consiste em componentes que lidam com a interação entre clientes e a camada de negócios. Depois de receber uma solicitação do cliente, a camada da web faz o seguinte:
</p>
<br>
<ul><li>1. Coleta entrada do cliente</li>
<li>2. Controla o fluxo de telas ou páginas no cliente</li>
<li>3. Mantém o estado dos dados da sessão de um usuário</li>
<li>4. Obtém resultados dos componentes na camada de negócios</li>
<li>5. Gera conteúdo dinâmico em vários formatos para o cliente</li></ul>
<br>
<p>A arquitetura multicamada do Java EE tem um tremendo impacto no desenvolvimento de aplicativos corporativos Java. Um aplicativo corporativo Java pode ser definido como um aplicativo Java que utiliza os serviços corporativos oferecidos pelo Java EE. De fato, um aplicativo da web pode ser classificado como um aplicativo corporativo se utilizar serviços Java EE na forma de componentes compactados na camada da web. O Java EE isola esses serviços funcionalmente em camadas separadas,fornecendo um modelo de aplicativo no qual os aplicativos corporativos Java devem ser construídos. Como conseqüência, o aplicativo corporativo Java reflete a arquitetura multicamada do Java EE.</p><br>
<P><i> A Figura abaixo ilustra uma visão generalizada das camadas de um aplicativo Web típico.</i></P>
<br>
<img src="imagens\jee7\webcamadas.jpg">
<br>
<P>Cada camada é uma área de preocupação para a aplicação. Por exemplo, a camada da web lida apenas com o emprego dos componentes da camada da web do Java EE. Ter camadas diferentes em um aplicativo resulta no que é chamado de separação de preocupações. Em termos de implementação, essa separação de preocupações é alcançada usando interfaces de granulação grossa</P>

<P>A preocupação é o recurso, funcionalidade ou funções de negócios com as quais o desenvolvedor do aplicativo precisa se preocupar. O cruzamento de tais preocupações é inerente a sistemas complexos e leva à dispersão de código, que é quando o código de uma preocupação abrange muitos módulos e emaranhamento de código, que é quando o código de um módulo se concentra em abordar várias preocupações.
A dispersão e emaranhamento de código levam a uma falta de clareza, redundância, rigidez e refatoração contínua. </P>
<p>Logo abaixo uma ilustração de como os serviços do sistema de log, transação e segurança cortam as funções de negócios do aplicativo.</p>
<br>
<img src="imagens\jee7\systemlog.jpg">
<br>
<p><b>BookService</b> também está envolvido com os serviços do sistema. Cada objeto conhece e é responsável pelo registro, segurança e transação. Um método, por exemplo, para comprar um livro no BookService deve se preocupar apenas com a compra do livro e não com a segurança ou a transação. A separação de preocupações, um dos principais objetivos da engenharia de software, permite que você lide com cada serviço por conta própria e, assim, faz o seguinte:</p>
<br>
<ul>
<li>1- Promove a rastreabilidade dentro e entre os artefatos do sistema, durante todo o ciclo de vida do sistema</li>
<li>2- Controla o impacto causado pela mudança, fornecendo espaço para evolução e adaptação não invasiva</li>
<li>3- Promove o desenvolvimento de unidades coesas, facilitando a reutilização</li>
</ul>
<br>
</section>
<section id="camadweb">
<h4>Camada Web</h4>

<p>A camada da web de um aplicativo da web consiste nos componentes da camada da web do Java EE, como servlets e JSP. A camada da web pode acessar a camada de serviço, mas não deve haver um acoplamento rígido entre a camada da web e a camada de serviço. Ou seja, alterar a camada de serviço não deve impactar a camada da web.</p>

</section>
<section id="dadoscamada">
<h4>Camada de Acesso aos Dados</h4>
<p>A camada de acesso a dados consiste nos componentes da camada de dados do Java EE, como JDBC e JPA. Essa camada não deve conter nenhuma lógica comercial. Essa camada abstrai o mecanismo de persistência real (em outras palavras, JDBC ou JPA) da camada de serviço, fornecendo a interface de granulação grossa para a camada de serviço.</p>
<br>
</section>
<section id="frmweb">
<h2>Framework Java Web </h2>
<p>Embora o Java EE faça um ótimo trabalho de padronização da infraestrutura corporativa, fornecendo um modelo de aplicativo e fornecendo componentes adequados para o desenvolvimento de aplicativos da Web, dois grandes problemas estão associados a ele.</p>
<br>
<ul>

<li>1- A interação direta com os componentes Java EE geralmente resulta em código clichê massivo e até em redundância de código.</li>
<li>2- Criar um aplicativo corporativo usando a infraestrutura Java EE é uma tarefa não trivial que requer muita experiência. Os membros da equipe geralmente envolvidos na criação de um aplicativo Java EE corporativo atuam em funções variadas e todos eles podem não ter o nível de conhecimento que atende aos critérios do Java EE.</li>
</ul>
<br>
<p>. A Tabela abaixo descreve uns Fameworks da Web, porém o que vamos utilizar aqui é o <b>Struts 2</b>.</p>
<br>
<div style="overflow-x:auto;">
<table class="w3-table-all">
<tr><th>Frameorks web</th><th>Linguagem</th><th>download de</th></tr>
<tr><td>Struts 2</td><td>Java</td><td>http://struts.apache.org/download.cgi#struts2314</td></tr>
<tr><td>Spring Web MVC</td><td>Java</td><td>www.springsource.org/spring-community-download</td></tr>
<tr><td>JSF 2</td><td>Java</td><td>www.oracle.com/technetwork/java/javaee/downloads/index.html</td></tr>
<tr><td>Grails 2</td><td>Groovy</td><td>www.grails.org/download</td></tr>
<tr><td>Play 2</td><td>Java e Scala</td><td>www.playframework.com/download</td></tr>
</table>
</div>
<br>
<p>Agora que você examinou os três principais participantes que unem forças na construção de aplicativos da web Java modernos (as linguagens JVM, Java EE e as estruturas da web Java), é hora de se aprofundar em algumas especificidades sobre Java.
</p>
<p>A seção a seguir apresenta o Java para que você possa construir seu primeiro aplicativo Java independente.</p>
</section>
<section id="intrdjava">
<h1>A Introdução ao Java</h1>

<p>Um aplicativo Java é um programa de computador que é executado quando você usa o comando java para ativar a JVM. Na linguagem de programação Java, todo o código-fonte é gravado primeiro em arquivos de texto sem formatação (no Bloco de Notas, por exemplo, ou em qualquer editor de texto) com a extensão .java. Os arquivos de origem são compilados pelo compilador <b>javac</b> em arquivos <b>.class</b> que contêm instruções de bytecode. A JVM lê essas instruções de bytecode e as converte nas operações de linguagem de máquina que cada computador executa. Ao disponibilizar a JVM em muitas plataformas, a Sun transformou o Java em uma linguagem de plataforma cruzada. Conforme mostrado na Figura abaixo, o mesmo bytecode pode ser executado em qualquer sistema operacional para o qual uma JVM foi desenvolvida.</p>
<br>
<img src="imagens\jee7\croosjava.jpg">
<br>
<p>Como a JVM está disponível em muitos sistemas operacionais diferentes, os mesmos arquivos <b>.class</b> podem ser executados no Windows, Unix, Linux ou Mac OS. Na seção a seguir, mostrarei como configurar o ambiente de desenvolvimento.</p>
</section>
<section id="confambdev">
<h2>Configurando o Ambiente de Desenvolvimento</h2>

<p>O JRE inclui uma JVM e as principais bibliotecas; é essencialmente apenas um ambiente para executar bytecode. O JDK inclui o JRE, um compilador Java (javac) e outras ferramentas - o software básico necessário para escrever e compilar programas Java.
Antes de poder começar a compilar e executar programas Java, é necessário fazer o download e instalar o JDK e configurar algumas variáveis ​​de ambiente do sistema.</p>
<p>Para aproveitar melhor o conteúdo você deve instalar o Java 8. Para obter a versão mais recente do JDK)), siga estas etapas:</p>
<br>
<ul>
<li>1.  Open www.oracle.com/technetwork/java/javase/downloads/index.html no 
web browser.</li>
<li>2.  Click o botão Download JDK .</li>
</li>3.  Siga as instruções fornecida pelo web site.</li>
<li>4.  Execute o instalador e aceite os padrões.</li>
</ul>
<br>


<p>Para confirmar que você instalou o JDK corretamente, digite <b>javac</b> na linha de comandos de qualquer diretório em sua máquina. Se você vir instruções sobre como executar o javac corretamente, você o instalou com sucesso.</p>
</section>
<section id="devappide">
<h4>Desenvolvendo aplicações Java com uma IDE</h4>

<p>Aqui, você usará o ambiente de desenvolvimento integrado ao Eclipse Neon (IDE). Para fazer o download, siga estas etapas:</p>
<br>
<ul>

<li>1. Abra www.eclipse.org/downloads/ em um navegador da web.</li>
<li>2. Siga as instruções fornecidas pelo site.</li>
<li>3. Execute o instalador e aceite os padrões.</li>

</ul>
<br>
</section>
<section id="criarprojeto">
<h4>Criar o primeiro Projeto no IDE</h4>
<p>Depois de iniciar o Eclipse, você pode criar um novo projeto da seguinte maneira:</p>
<br>
<ul>
<li>1. No menu Arquivo, selecione Novo e, em seguida, selecione Projeto. A janela Novo Projeto é exibida.</li>
<li>2. Na janela Novo Projeto, clique duas vezes em Projeto Java. A janela New Java Project aparece, conforme ilustrado na Figura</li>
<li>3. Digite o capítulo1 no campo "Nome do projeto".</li>
<li>4. Clique em Concluir. Você pode alterar várias outras opções aqui. No entanto, para nossos propósitos, as configurações padrão funcionam perfeitamente.</li>

</ul>
<br>
<img src="imagens\jee7\eclipse1.jpg">
<br>
</section>
<section id="criarapp">
<h4>Criando uma Aplicação</h4>
<p>Para criar uma classe com um método principal para o seu primeiro programa, siga estas etapas:</p>
<p>1- Clique com o botão direito do mouse no projeto <b>capitulo1</b> no Eclipse Package Explorer, escolha Novo e, em seguida, escolha Classe. A janela Nova Classe Java é exibida, como mostra a Figura</p>
<br>
<img src="imagens\jee7\eclipse2.jpg">
<br>
<p>Um pacote agrupa classes. No campo Nome, você pode digitar o nome da classe, que é OlaMundo. Marque a caixa de seleção que fornece um método principal ( public static void main (String args [])). Quando terminar, você deve ter uma classe semelhante ao programa abaixo.</p>
<p>2. Clique em "Gerar comentários". Isso será explicado em breve</p>
<pre class="brush:java">
/**
 * 
 */
package alpi.olamundo;

/**
 * @author alansantos
 *
 */
public class OlaMundo {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
</pre>
<p>Agora você pode executar o aplicativo clicando no botão Executar na barra de ferramentas ou escolhendo Executar no menu Executar.
O Eclipse então exibe um painel do console sob a área de código que mostra a saída do seu programa. Nesse caso, ele diz "Ola mundo".</p>
<h4>Comentários Javadoc</h4>
<p>Um comentário Javadoc começa com a sequência de caracteres / ** e termina com a sequência de caracteres * /. O compilador ignora tudo entre essas seqüências de caracteres. No Eclipse, você pode
adicione os comentários do Javadoc selecionando o nome da classe ou do método e pressionando Alt + Shift + J. Para ver todos os atalhos no Eclipse, pressione Ctrl + Shift + L.</p>
<br>
<p>Para gerar o Javadoc, selecione o projeto no Eclipse, selecione o menu Projeto e clique em Gerar Javadoc, conforme mostrado na Figura.</p>
<br>
<img src="imagens\jee7\eclipse3.jpg">
<br>
<p>Uma janela será aberta onde você pode selecionar projetos Java ou seus recursos subjacentes para os quais um Javadoc precisa ser gerado. Várias outras opções também estão disponíveis; você pode selecionar se deseja gerar um Javadoc para APIs públicas / privadas e assim por diante. Por enquanto, configure o arquivo javadoc.exe no campo “Comando Javadoc” e procure e selecione a pasta de destino onde o Javadoc deve ser gerado.</p>
<br>
<img src="imagens\jee7\eclipse4.jpg">
<br>
<p>Clique em Concluir. No console, você pode ver o progresso da geração do Javadoc. A Figura abaixo mostra o Javadoc gerado.</p>
<br>
<img src="imagens\jee7\eclipse5.jpg">
<br>
</section>
<section id="bookstoreapp">
<h2>A Aplicação Bookstore</h2>
<p>Em vez de simplesmente declarar um Framework Web como o melhor,  pretendemos mostrar os pontos fortes das estruturas da Web mais populares por meio de um aplicativo de livraria do mundo real. O desenvolvimento de um aplicativo real completo que requer uma colaboração contínua de funcionalidades dinâmicas, e o código para construir esses componentes é artificial e muito envolvido. Ao longo deste contéudo você aprenderá como usar o Java EE e o framework da web Java para criar o aplicativo da web da livraria. Neste capítulo, você dará o primeiro passo ao criar um aplicativo de livraria Java independente tradicional. No próximos capítulos , você transformará o aplicativo independente em um aplicativo da web.</p>
<p>Usarei um único estudo de caso de aplicativo da web para demonstrar como escrever um aplicativo da Web usando servlets e JSPs e o Framework da Web,  Struts 2.</p>
</section>
<section id="modeldados">
<h2>Aplicação para o modelo de Dados do Bookstore</h2>

<p>Esta seção apresenta um modelo de dados simples que será usado para o aplicativo da web bookstore . Expandirei o modelo progressivamente a cada capítulo, conforme a necessidade.
O modelo é um banco de dados de livros simples que consiste em três tabelas</p>
<ul>
	<li>A tabela CATEGORY armazena as diferentes categorias de livros; categorias incluem Java, Scala e assim por diante.</li>
<li>A tabela BOOK armazena os detalhes do livro, como títulos.</li> 
<li>A tabela AUTHOR armazena os detalhes dos autores</li> 	
</ul>


<p>Cada categoria pode ter zero ou mais livros. Por exemplo, pode haver zero ou mais livros na categoria Java na livraria. Em outras palavras, há um relacionamento um para muitos entre as tabelas Category e Book. Da mesma forma, cada livro pode ter um ou mais autores. Em outras palavras, há um relacionamento um para muitos entre as tabelas Book e Author. O relacionamento de entidade (ER)
O diagrama da Figura abaixo ilustra esse relacionamento.</p>

<br>
<img src="imagens\jee7\eclipse6.jpg">
<br>
<p>Este modelo de dados não está pronto para produção, porque você pode ter um relacionamento muitos para muitos entre Category e Book, e pode ter um relacionamento muitos para muitos entre Book e Author. Eu mantive o modelo de dados simples, para que a complexidade do modelo de dados não atrapalhe o aprendizado da mecânica da construção de um aplicativo da web. No entanto, você pode, por exemplo, modelar um relacionamento muitos para muitos entre Book e Author, conforme ilustrado na Figura</p>
<br>
<img src="imagens\jee7\eclipse7.jpg">
<br>
<p>O único objetivo da tabela BookAuthor é fornecer um relacionamento muitos-para-muitos entre Book e Author.</p>
<br>

<p><i>Como mostra a Figura acima, existe um relacionamento um para muitos entre Book e BookAuthor, e há um relacionamento um para muitos entre Author e BookAuthor. De fato, o único objetivo da tabela BookAuthor é fornecer um relacionamento muitos para muitos entre Book e Author - em outras palavras, um autor pode escrever muitos livros, e um livro pode ter muitos autores.</i></p>
<br>
<p>Devido à profusão de aplicativos da web em vários domínios, surgiram muitos bancos de dados relacionais e não relacionais, como o NoSQL. Usarei o MySQL porque é o sistema de gerenciamento de banco de dados gratuito mais amplamente usado. Para instalar o MySQL, vá para http://dev.mysql.com/downloads/ e click Downloads. VocÊ pode baixar Mysql Server 5.6 ou mais recente. VocE pode ver ass instruçoes para instalação do Mysql em: https://dev.mysql.com/doc/refman/5.6/en/</p>
<br>
<p>Para criar o banco de dados de livros, use o seguinte comando:</p>
<pre class="brush:sql">create database books;</pre>
<p>Você precisa instruir o MySQL para criar tabelas no banco de dados books usando o seguinte comando:</p>
<pre class="brush:sql">use books;</pre>
<p>Agora você pode criar as tabelas usando as declarações:</p>
<p><b>Criando tabela para aplicativo</b></p>
<pre class="brush:sql">
CREATE TABLE CATEGORY (
ID INT NOT NULL AUTO_INCREMENT ,
CATEGORY_DESCRIPTION VARCHAR(20) NOT NULL ,
PRIMARY KEY (ID)
);
-----------------------------------------
CREATE TABLE BOOK (
ID INT NOT NULL AUTO_INCREMENT,
CATEGORY_ID INT NOT NULL ,
BOOK_TITLE VARCHAR(60) NOT NULL,
PUBLISHER VARCHAR(60) NOT NULL ,
PRIMARY KEY (ID) ,
CONSTRAINT FK_BOOK_1 FOREIGN KEY (CATEGORY_ID) REFERENCES CATEGORY(ID)
);
-----------------------------------------------
CREATE TABLE AUTHOR (
ID INT NOT NULL AUTO_INCREMENT ,
BOOK_ID INT NOT NULL ,
FIRST_NAME VARCHAR(20) NOT NULL ,
LAST_NAME VARCHAR(20) NOT NULL ,
PRIMARY KEY (ID) ,
CONSTRAINT FK_AUTHOR_1 FOREIGN KEY (BOOK_ID) REFERENCES BOOK (ID)
);
</pre>
<p>Você pode verificar as tabelas criadas use o comando <b>show tables</b></p>
<p>Você também pode verificar a estrutura das tabelas use o comando describre< nome-tabela > ou desc< nome-tabela >.</p>
<p>Para pupular as tabelas usando a declaração <b>insert</b>, como a seguir:</p>
<pre class="brush:sql">
insert into category (category_description) values ('Clojure');
insert into category (category_description) values ('Groovy');
insert into category (category_description) values ('Java');
insert into category (category_description) values ('Scala');
</pre>
<p>Você pode verificar a tabela Category pupolada usando comando:</p>
<pre class="brush:sql"> Select * from category;</pre>
<div style="overflow-x:auto;">
<table>
	<tr><td>ID</td><td>CATEGORY_DESCRIPTION</td></tr>
<tr><td>1</td><td>Clojure</td></tr>
<tr><td>2</td><td>Groovy</td></tr>
<tr><td>3</td><td>Java</td></tr>
<tr><td>4</td><td>Scala</td></tr>
</table>
</div>
</pre>
<pre class="brush:sql"> 
insert into Book (CATEGORY_ID, BOOK_TITLE, PUBLISHER) values (1, 'Practical Clojure', 'Apress');
insert into Book (CATEGORY_ID, BOOK_TITLE, PUBLISHER) values (2, 'Beginning Groovy, Grails and 
Griffon', 'Apress');
insert into Book (CATEGORY_ID, BOOK_TITLE, PUBLISHER) values (2, 'Definitive Guide to Grails 2', 
'Apress');
insert into Book (CATEGORY_ID, BOOK_TITLE, PUBLISHER) values (2, 'Groovy and Grails Recipes', 
'Apress');
insert into Book (CATEGORY_ID, BOOK_TITLE, PUBLISHER) values (3, 'Modern Java Web Development', 
'Apress');
insert into Book (CATEGORY_ID, BOOK_TITLE, PUBLISHER) values (3, 'Java 7 Recipes', 'Apress');
insert into Book (CATEGORY_ID, BOOK_TITLE, PUBLISHER) values (3, 'Java EE 7 Recipes', 'Apress') 
</pre>
<pre class="brush:sql">
insert into Author (BOOK_ID, FIRST_NAME, LAST_NAME) values (1, 'Luke', 'VanderHart');
insert into Author (BOOK_ID, FIRST_NAME, LAST_NAME) values (2, 'Vishal', 'Layka');
insert into Author (BOOK_ID, FIRST_NAME, LAST_NAME) values (3, 'Jeff', 'Brown');
insert into Author (BOOK_ID, FIRST_NAME, LAST_NAME) values (4, 'Bashar', 'Jawad');
insert into Author (BOOK_ID, FIRST_NAME, LAST_NAME) values (5, 'Vishal', 'Layka');
insert into Author (BOOK_ID, FIRST_NAME, LAST_NAME) values (6, 'Josh', 'Juneau');
insert into Author (BOOK_ID, FIRST_NAME, LAST_NAME) values (7, 'Josh', 'Juneau');
insert into Author (BOOK_ID, FIRST_NAME, LAST_NAME) values (8, 'Jeff', 'Friesen');
</pre>
</section>
<section id="camdacesso">
<h1> Camada de Acesso a Dados</h1>

<p>Agora que o banco de dados está pronto, você criará a camada de acesso a dados para o aplicativo. A camada de acesso a dados recuperará os dados via JDBC do banco de dados e mapeará diretamente o conjunto de resultados em objetos Java. Esses objetos Java são os objetos de domínio no aplicativo que são a representação Java das tabelas no banco de dados. A camada de acesso a dados é responsável pela interface com o mecanismo de persistência subjacente de maneira transparente, a fim de armazenar e recuperar objetos do banco de dados.Essa transparência significa que a camada de acesso a dados pode alternar o mecanismo de persistência de tecnologias simples de persistência JDBC para ORM, como Hibernate, JPA etc., sem afetar o cliente da camada de acesso a dados. Essa transparência é obtida através do padrão objeto de acesso a dados (DAO), O objeto DAO fornece uma interface para o banco de dados ou o mecanismo de persistência subjacente, abstraindo assim a implementação subjacente do cliente.</p>
<br>
<img src="imagens\jee7\padraodao.jpg">
<br>
<p>O aplicativo de mapas DAO chama o mecanismo de persistência e fornece operações de dados específicas sem expor detalhes do banco de dados. A interface DAO abstrai os detalhes de implementação do acesso aos dados do cliente (objeto de aplicativo) e fornece os objetos específicos do domínio que o cliente (objeto de aplicativo) precisa.</p><br>
<p>Primeiro, você precisa criar as classes específicas do domínio para as representações de objetos Java das tabelas de banco de dados. </p>

<pre class="brush:java">
//Model: Category
package com.alpi.books.model;
public class Category {
private Long id;
private String categoryDescription;
public Long getId() {
return id;
}
public void setId(Long id) {
this.id = id;
}
public String getCategoryDescription() {
returncategoryDescription;
}
public void setCategoryDescription(String categoryDescription) {
this.categoryDescription = categoryDescription;
}
public String toString() {
return "Category - Id: " + id + ", Category Description: "
+ categoryDescription;
}
}
</pre>
<br>
<pre class="brush:java">
//Model: Book
package com.alpi.books.model;
import java.util.List;
import com.alpi.books.model.Author;
public class Book {
private Long id;
private Long categoryId;
private String bookTitle;
private List&ltAuthor> authors;
private String publisherName;
public Long getId() {
return id;
}
public void setId(Long id) {
this.id = id;
}
public Long getCategoryId() {
return categoryId;
}
public void setCategoryId(Long categoryId) {
this.categoryId = categoryId;
}
public String getBookTitle() {
return bookTitle;
}
public void setBookTitle(String bookTitle) {
this.bookTitle = bookTitle;
}
public List&ltAuthor> getAuthors() {
return authors;
}
public void setAuthors(List272103_1_En authors) {
this.authors = authors;
}
public String getPublisherName() {
return publisherName;
}
public void setPublisherName(String publisherName) {
this.publisherName = publisherName;
}
public String toString() {
return "Book - Id: " + id + ", Book Title: " + bookTitle;
}
}</pre>
<br>

<pre class="brush:java">
//Model: Author
package com.alpi.books.model;
public class Author {
private Long id;
private Long bookId;
private String firstName;
private String lastName;
public Long getId() {
return id;
}
public void setId(Long id) {
this.id = id;
}
public Long getBookId() {
return bookId;
}
public void setBookId(Long bookId) {
this.bookId = bookId;
}
public String getFirstName() {
return firstName;
}
public void setFirstName(String firstName) {
this.firstName = firstName;
}
public String getLastName() {
return lastName;
}
public void setLastName(String lastName) {
this.lastName = lastName;
}
public String toString() {
return "Author - Id: " + id + ", Book id: " + bookId + ", First Name: "
+ firstName + ", Last Name: " +lastName;
}
}
</pre>

<p>Agora, vamos começar com uma interface simples para <b>BookDAO</b> que encapsula todo o acesso a dados por seu aplicativo da web.</p>
<pre class="brush:java">
	//BookDAO Interface
 package com.alpi.books.dao;

 import java.util.List;

 import com.alpi.books.model.Book;
 import com.alpi.books.model.Category;

 public interface BookDAO {
 public List&ltBook>findAllBooks();

 public List&ltBook>searchBooksByKeyword(String keyWord);

 public List&ltCategory>findAllCategories();

 public void insert(Book book);

 public void update(Book book);

 public void delete(Long bookId);

 }
</pre>
<ul>
<li><b>Linha 10:</b> este é o método <b>findAllBooks()</b> para listar todos os livros do banco de dados.</li>
<li>A <b>linha 12</b>: <b>SearchBooksByKeyword (String keyWord)</b> permite que o usuário pesquise livros por palavra-chave no título do livro ou pelo nome e sobrenome do autor.</li>
<li><B>Linha 14</b>: <B>findAllCategories()</b> é requerida pelo aplicativo para fornecer uma lista categorizada de livros.</li>
</ul>
<br>
<p>Os métodos nesta interface correspondem aos termos CRUD (em outras palavras, (CREATE, READ, UPDATE, DELETE)criar, ler, atualizar e excluir) do aplicativo.</p>

<p> Agora a implementação da interface BookDAO</p>
<pre class="brush:java">

 package com.alpi.books.dao;

 import java.sql.Connection;
 import java.sql.DriverManager;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.ArrayList;
 import java.util.List;

 import java.alpi.books.model.Author;
 import java.alpi.books.model.Book;
 import java.alpi.books.model.Category;

 public class BookDAOImpl implements BookDAO {

 static {
 try {
 Class.forName("com.mysql.jdbc.Driver");
 } catch (ClassNotFoundException ex) {
 }
 }

 private Connection getConnection() throws SQLException {
 return DriverManager.getConnection("jdbc:mysql://localhost:3306/books",
 "root", "password");
 }

 private void closeConnection(Connection connection) {
 if (connection == null)
 return;
 try {
 connection.close();
 } catch (SQLException ex) {
 }
 }

 public List&ltBook> findAllBooks() {
 List&ltBook> result = new ArrayList&lt>();
 List&ltAuthor> authorList = new ArrayList&lt>();

 String sql = "select * from book inner join author on book.id = author.book_id";

 Connection connection = null;
 try {
 connection = getConnection();
 PreparedStatement statement = connection.prepareStatement(sql);
 ResultSet resultSet = statement.executeQuery();
 while (resultSet.next()) {
 Book book = new Book();
 Author author = new Author();
 book.setId(resultSet.getLong("id"));
 book.setBookTitle(resultSet.getString("book_title"));
 book.setCategoryId(resultSet.getLong("category_id"));
 author.setBookId(resultSet.getLong("book_Id"));
 author.setFirstName(resultSet.getString("first_name"));
 author.setLastName(resultSet.getString("last_name"));
 authorList.add(author);
 book.setAuthors(authorList);
 book.setPublisherName(resultSet.getString("publisher"));
 result.add(book);
 }
 } catch (SQLException ex) {
 ex.printStackTrace();
 } finally {
 closeConnection(connection);
 }
 return result;
 }


 public List&ltBook> searchBooksByKeyword(String keyWord) {
 List&ltBook> result = new ArrayList&lt>();
 List&ltAuthor> authorList = new ArrayList&lt>();

 String sql = "select * from book inner join author on book.id = author.book_id"
 + " where book_title like '%"
 + keyWord.trim()
 + "%'"
 + " or first_name like '%"
 + keyWord.trim()
 + "%'"
 + " or last_name like '%" + keyWord.trim() + "%'";

 Connection connection = null;
 try {

 connection = getConnection();
 PreparedStatement statement = connection.prepareStatement(sql);
 ResultSet resultSet = statement.executeQuery();
 while (resultSet.next()) {
 Book book = new Book();
 Author author = new Author();
 book.setId(resultSet.getLong("id"));
 book.setBookTitle(resultSet.getString("book_title"));
 book.setPublisherName(resultSet.getString("publisher"));
 author.setFirstName(resultSet.getString("first_name"));
 author.setLastName(resultSet.getString("last_name"));
 author.setBookId(resultSet.getLong("book_id"));
 authorList.add(author);
 book.setAuthors(authorList);
 result.add(book);
 }
 } catch (SQLException ex) {
   ex.printStackTrace();
 } finally {
 closeConnection(connection);
 }

 return result;
 }

 public List&ltCategory> findAllCategories() {
 List&ltCategory> result = new ArrayList&lt>();
 String sql = "select * from category";

 Connection connection = null;
 try {
 connection = getConnection();
 PreparedStatement statement = connection.prepareStatement(sql);
 ResultSet resultSet = statement.executeQuery();
 while (resultSet.next()) {
 Category category = new Category();
 category.setId(resultSet.getLong("id"));
 category.setCategoryDescription(resultSet
 .getString("category_description"));
 result.add(category);
 }
 } catch (SQLException ex) {
 ex.printStackTrace();
 } finally {
 closeConnection(connection);
 }
 return result;
 }

 public void insert(Book book) {
 }

 public void update(Book book) {
 }

 public void delete(Long bookId) {

 }
 }	
</pre>

<p>O código acima é uma implementação da interface <b>BookDAO</b> para interagir com; essa interação inclui a conexão com o banco de dados e a seleção, exclusão e atualização de dados via JDBC puro. JDBC fornece o driver que é específico para cada banco de dados e permite que Java codifique o banco de dados.</p>
<ul>
	<li><b>Linhas 18 a 37</b>: Essas linhas mostram o código necessário para gerenciar uma conexão JDBC.</li>

<li><b>Linha 26:</b> O método getConnection() retorna uma interface java.sql.Connection implementada pelo driver. Essa interface permite executar instruções SQL no banco de dados. Para que isso funcione, é necessário fornecer um arquivo MySQL Connector/J JAR. Um MySQL Connector/J é um driver Java nativo que converte chamadas JDBC em um protocolo de rede que o banco de dados MySQL possa entender. O DriverManager gerencia drivers e fornece métodos estáticos para estabelecer conexões com o banco de dados.</li>
</ul>
<br>
<p><i>Você pode fazer o download do MySQL Connector / J em http://dev.mysql.com/downloads/connector/j/. Coloque esse conector JAR no caminho de classe(classpath) do projeto.</i></p><br>
<ul>
<li><b>Linhas 30 a 37</b>: As conexões precisam ser fechadas porque as conexões são caras quando se trata do desempenho do aplicativo.</li>
<li>Linhas 39 a 144: essas linhas são implementações de serviços CRUD na interface BookDAO.</li>
<li>Linhas 67, 108 e 133: Você criou uma conexão para cada instrução nos serviços CRUD. Você precisa fechar essas conexões; mantê-los abertos resultará no mau desempenho do aplicativo</li>
</ul>
</section>
<section id="clientacess">
<h2>Cliente para a camada de acesso a dados</h2>
<p>Agora que sua camada de acesso a dados está pronta, você a consultará com um aplicativo Java independente. Depois, você substituirá esse aplicativo Java por um aplicativo da web.</p>

<pre class="brush:java">
  //Stand-Alone Bookstore Java App
 package com.alpi.books.client;
 import java.util.List;

 import com.alpi.books.dao.BookDAO;
 import com.alpi.books.dao.BookDAOImpl;
 import com.alpi.books.model.Book;
 public class BookApp {
 private static BookDAO bookDao = new BookDAOImpl();

 public static void main(String[] args) {
 // Lista todos livros
 System.err.println("Listing all Books:");
 findAllBooks();
 System.out.println();
 // pesquisar livro pela palavra chave
 System.err.println("Search book by keyword in book title : Groovy:");

 searchBooks("Groovy");
 System.out.println();

 System.err.println("Search book by keyword in author's name : Josh:");

 searchBooks("Josh");


 }

 private static void findAllBooks() {
 List&ltBook> books = bookDao.findAllBooks();
 for (Book book : books) {
 System.out.println(book);
 }
 }
 private static void searchBooks(String keyWord){
 List&ltBook> books = bookDao.searchBooksByKeyword(keyWord);
 for (Book book : books) {
 System.out.println(book);
 }
 }
 }
 </pre>
<p>Figura abaixo ilustra a estrutura de diretórios  o arquivo BookApp.java e a exibição no console quando é executado o aplicativo (stand-alone)independente. </p>
 <br>
 <img src="imagens\jee7\projetomain.jpg">
 <br>
 </section>
 <section id="servletjsp">
 <h2>Construindo aplicativos da Web usando servlets e JSP</h2>
 <p>Os principais protocolos da Internet substanciam e sustentam a Web, portanto, entender esses protocolos é fundamental para entender como os aplicativos da Web são desenvolvidos.
</p>
<p>A Internet é uma rede colossal de redes e, em geral, todas as máquinas na Internet podem ser classificadas em dois tipos: o servidor e o cliente. O cliente é a máquina que está solicitando algumas informações e o servidor é a máquina que fornece essas informações. Os dados de informações que fluem do provedor de informações (ou seja, o servidor) para o solicitante de informações (ou seja, o cliente) são vinculados por uma regra definida que governa a organização das informações a serem transmitidas pelo servidor e a remoção da organização de informações. as informações a serem traduzidas ou lidas pelo cliente. Esta regra é chamado de protocolo. O navegador da Web (ou seja, o cliente), o servidor da Web (ou seja, o servidor) e o aplicativo da Web conversam entre si por meio do HTTP (Hypertext Transfer Protocol). Os clientes enviam solicitações HTTP para os servidores da Web e os servidores da Web retornam os dados solicitados na forma de respostas HTTP. Os clientes HTTP e os servidores HTTP são a base que está na base da World Wide Web, e o HTTP é a língua franca da Web.</p>
<p>HTTP é um protocolo sem estado de solicitação-resposta(request-response), na visão do servidor da web, qualquer solicitação é a primeira solicitação do navegador da web. Quando um cliente faz uma solicitação para o recurso, a solicitação também inclui a identificação do recurso que está sendo solicitado, na forma de um URL (Uniform Resource Locator). Os URLs são descritos na RFC 3986 como uma maneira uniforme de identificar exclusivamente um recurso. Os URLs são projetados para fornecer implicitamente um meio de localizar um recurso, descrevendo seu "local" em uma rede.</p> 
<br>
<p><i>Uma URL é uma forma concreta de URI (Uniform Resource Identifier), que é um mecanismo para distinguir entidades. Mas os URIs em si são abstratos. Existem duas formas concretas de URI: URL e Nome de Recurso Uniforme (URN). A URN ainda é experimental e não é amplamente adotada.</i></p>
<br>
<p>Uma URL genérica é uma sequência hierárquica de componentes, estruturada como squeme://hostName: portNumber/path/resource?query string.
Para identificar as partes de um URL, considere um URL que lista os detalhes de um livro no site da livraria, conforme mostrado aqui:</p>
<pre class="brush:html>">http://www.seubookstore.com/bookstore:80/bookServlet?action=bookDetails</pre>
<p>Esta tabela mostra anatomia da URL:</p>
<br>
<div style="overflow-x:auto;">
<table class="w3-table-all">
  <tr><th>Scheme</th><th>Hostname</th><th>PortNumber</th><th>Path</th><th>Resource</th><th>QueryString</th></tr>
<tr><td>http</td><td>www.seubookstore.com</td><td>80</td><td>bookstore</td><td>bookServlet</td><td>action=bookDetails</td></tr>
</table>
</div>
<br>
<p>O nome do host e o número da porta juntos são denominados autoridade. Por padrão, um servidor Web como o Tomcat, conforme explicado mais adiante, escuta solicitações de entrada na porta 8080. Algumas partes da URL mostrada na tabela são opcionais, incluindo o número da porta (que é o padrão das portas conhecidas 80). e 443 para os esquemas HTTP e HTTPS, respectivamente) e a sequência de consultas.</p>
<br>
<p><i>HTTPS é HTTP sobre SSL (Secure Sockets Layer); permite comunicações seguras e criptografadas.</i></p>
<br>
<p>Quando presente, uma string de consulta(query string) é uma série de pares nome-valor precedidos por um ponto de interrogação(?) E um e comercial(&) que separa os pares.</p><br>
<p><i>As cadeias de consulta são suportadas apenas para o método GET. Existem outros métodos de protocolo HTTP, como POST, DELETE e PUT</i></p>
<br>
<p>Um aplicativo da web é uma coleção de componentes da web que trabalham juntos para fornecer uma funcionalidade específica na web. Na especificação Java EE, um componente da web é definido para ser uma página Servlet ou Java Server Page (JSP).
</p>
<br>
<p><i>Além de servlets e páginas JSP, um aplicativo da web também pode incluir recursos estáticos, como documentos HTML, imagens e os metadados ou arquivos de configuração que definem as propriedades do aplicativo da web; no entanto, esses itens não são considerados componentes da web.</i></p>
<br>
<p>O aplicativo da web e seus componentes constituintes são gerenciados e executados dentro do contêiner da web, também chamado de contêiner de servlet, que fornece recursos adicionais ao aplicativo da web, como segurança. Quando o servidor da Web obtém uma solicitação de funcionalidade específica que um componente da Web específico (como um servlet ou uma página JSP) pode fornecer, o servidor da Web encaminha a solicitação para
o contêiner de servlet no qual o componente da web reside. Todas as solicitações para o conteúdo dinâmico (ou seja, todas as solicitações ao componente da web responsável por gerar o conteúdo dinâmico) são mediadas pelo contêiner do servlet.</p>
<br>
<img src="imagens\jee7\servlet.jpg">
<br>
<p>As especificações Java EE Servlet e JSP descrevem o contrato de serviço que um contêiner de servlet deve fornecer e especifica como um servlet deve usar esses serviços. Em termos de implementação, um servlet é uma classe Java que atua como um recurso dinâmico da web.</p>
</section>
<section id="servlets"> 
<h2>Servlets</h2>
<p>Servlets são a unidade central de processamento de um aplicativo da web Java e são responsáveis ​​pela maior parte do processamento exigido por um aplicativo da web. Especificamente, um servlet é uma classe Java que implementa a Interface <b>javax.servlet.Servlet</b>. A interface <b>Servlet</b> define os métodos que todos os servlets devem implementar. “Um anel para governar todos eles!” Essa interface, juntamente com outros métodos, define os principais métodos do ciclo de vida, como <b>init()</b>, <b>service()</b> e <b>destroy()</b> para inicializar um servlet, atender solicitações e remover um servlet do servidor, respectivamente. A Tabela abaixo descreve todos os métodos da interface <b>javax.servlet.Servlet</b>.</p>
<br>
<div style="overflow-x:auto;">
<table class="w3-table-all">
<th>Tipo e Modificador</th><th>Método</th>
<tr><td>Void</td><td>init(ServletConfig config)</td></tr>
<tr><td>void</td><td>service(ServletRequest req, ServletResponse res)</td></tr>
<tr><td>void</td><td>destroy()</td></tr>
<tr><td>ServletConfig</td><td>getServletConfig()</td></tr>
<tr><td>String</td><td>getServletInfo()</td></tr>
</table>
</div>
<br>
<p>Os métodos de ciclo de vida são invocados pelo contêiner em instantes apropriados na vida de um servlet na seguinte sequência:</p>
<br>
<ul>
<li>1. O servlet é construído e, em seguida, inicializado com o método init.</li>
<li>2. Todas as chamadas dos clientes para o método de serviço são tratadas.</li>
<li>3. O servlet é destruído com o método de destruição, o lixo coletado e finalizado.</li>
</ul>
<br>
<p>Os métodos da interface do Servlet ilustrados na Tabela são explicados aqui:</p>
<ul>

<li><b>init(ServletConfig)</b>: Chamado pelo contêiner do servlet exatamente uma vez após instanciar o servlet. Este método deve ser concluído com êxito antes que o servlet seja um candidato para receber quaisquer solicitações.</li>
<li><b>service()</b>: chamado pelo contêiner do servlet, depois que o método init() do servlet for concluído com êxito, para permitir que o servlet responda a uma solicitação.</li>
<li><b>destroy()</b>: Chamado pelo contêiner para destruir o servlet e serve como um método no qual o servlet deve liberar recursos adquiridos antes de ser destruído.</li>
<li>getServletConfig(): permite que o servlet obtenha informações de inicialização na forma de um objeto ServletConfig retornado por esse método. O objeto ServletConfig contém parâmetros de inicialização e inicialização para o servlet.</li>         
<li><b>getServletInfo()</b>: permite que o servlet retorne suas próprias informações, como o autor e a versão do servlet.</li>
</ul>

<p> Você instalou a IDE Eclipse Neon ou ais recente. Você desenvolverá seu primeiro aplicativo da web no Eclipse nesta seção. Especificamente, você usará o Tomcat 8 como servidor HTTP e como contêiner de servlet. Você pode instalar o Tomcat 8 baixando a distribuição de origem do Tomcat como um arquivo ZIP em http://tomcat.apache.org/download-80.cgi.
Inicie o Eclipse e selecione a opção de menu Window ➤ Preferences para exibir o diálogo Preferences, conforme ilustrado na Figura.</p>
<br>
<img src="imagens\jee7\eclipseserv.jpg">
<br>
<p>No painel esquerdo desta caixa de diálogo, faça uma busca detalhada em Java JREs instalados e verifique se a versão do JRE8/JDK 8 instalada anteriormente aparece. Caso contrário, clique no botão Adicionar para adicionar uma referência ao seu JDK. Crie um projeto dinâmico da Web, selecionando Files ->New Project ->Dynamic Web Project, Nomeie o projeto <b>olamundo</b>, conforme mostrado na Figura</p>
<br>
<img src="imagens\jee7\projecteclipse.jpg">
<br>
<img src="imagens\jee7\olamundo.jpg">
<br>
<p>Clique em Avançar e verifique “Gerar descritor de implementação web.xml”, como mostra a Figura 2-6. Mais adiante veremos como é possível configurar o módulo da web sem o web.xml</p>
<br>
<img src="imagens\jee7\olamundoxml.jpg">
<br>
<p>Clique em Concluir e crie uma nova classe Java, conforme mostrado na Figura</p>
<br>
<img src="imagens\jee7\newclasse.jpg">
<br>
<img src="imagens\jee7\alpiolamundo.jpg">

<p>Modifique a classe HelloWorld gerada com o código </p>

<pre class="brush:java">
/**
 * 
 */
package alpi.olamundo;

/**
 * @author alansantos
 *
 */
import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class OlaMundo extends HttpServlet{

protected void doGet(HttpServletRequest request,
HttpServletResponse response)
{
try
{
response.setContentType("text/html");
PrintWriter printWriter = response.getWriter();
printWriter.println("&lth2>");
printWriter.println("Ola Mundo");
printWriter.println("&lt/h2>");
}
catch (IOException ioException)
{
ioException.printStackTrace();
}
}

}
</pre>
<p>Modifique o arquivo web.xml com o código abaixo:</p>
<pre class="brush:xml">
&lt? xml version="1.0" encoding="UTF-8"?>
&ltweb-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xmlns="http://xmlns.jcp.org/xml/ns/javaee" 
xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1">
&ltdisplay-name>olamundo&lt/display-name>
  
&ltservlet>
&ltservlet-name>OlaMundo&lt/servlet-name>
<servlet-class>alpi.olamundo.OlaMundo</servlet-class>
</servlet>
<servlet-mapping>
<servlet-name>OlaMundo</servlet-name>

<url-pattern>/ola</url-pattern>
</servlet-mapping>

<welcome-file-list>
<welcome-file>index.html</welcome-file>
<welcome-file>index.htm</welcome-file>
<welcome-file>index.jsp</welcome-file>
<welcome-file>default.html</welcome-file>
<welcome-file>default.htm</welcome-file>
<welcome-file>default.jsp</welcome-file>
</welcome-file-list>
&lt/web-app>
</pre>

<p>Agora precisamos configurar o servlet OlaMundo como um módulo da Web no Tomcat. Selecione Windows -> Show View -> Servers na barra de menus do Eclipse, conforme ilustrado na Figura</p>
<br>
<img src="imagens\jee7\showview.jpg">
<br>
<p>Na guia Servidores, clique com o botão direito do mouse e adicione o Tomcat 8 como o novo servidor, conforme mostrado na Figura.</p>
<br>
<img src="imagens\jee7\newserver.jpg">
<br>
<p>Em seguida, você terá que definir um novo servidor, conforme ilustrado na Figura</p>
<br>
<img src="imagens\jee7\tomcat8.jpg">
<br>
<p>Agora configure o projeto olamundo movendo os recursos para a direita na seção configurada, conforme mostrado na Figura</p>
<br>
<img src="imagens\jee7\addolamundo.jpg">
<br>
<p>Clique em Adicionar e o recurso será configurado no servidor. Depois clique em Concluir. Inicie o servidor e acesse o aplicativo usando o URL mostrado na Figura</p>
<br>
<img src="imagens\jee7\startolamundo.jpg">
<br>
<p>Agora você pode acessar seu primeiro aplicativo Web através do URL -><span>http://localhost:8080/olamundo/ola</span> </p>
<br>
<img src="imagens\jee7\olamundoweb.jpg">
<br>


<p>Na seção a seguir, você aprenderá como a solicitação flui pelo aplicativo e como o contêiner encontra o servlet no aplicativo olamundo que você desenvolveu. Então você usará o
Servlet OlaMundo para entender os métodos de ciclo de vida do servlet</p>
</section>
<section id="sevletolamundo">
<h3>Solicitar fluxo para o servlet OlaMundo</h3>

<p>A solicitação originada no navegador da Web flui através do servidor da Web e do contêiner do servlet antes que o servlet OlaMundo possa gerar a resposta, conforme explicado nas seções a seguir.</p>
<h3>Mensagem de solicitação HTTP</h3>
<p>O URL usado para acessar o aplicativo da web olamundo é http:// localhost:8080/olamundo/ola.
Quando o usuário acessa o aplicativo da web por meio dessa URL, o navegador da web cria a solicitação HTTP, conforme ilustrado no código abaixo.</p>

<pre class="brush:java">
//HttpRequest Message
GET /helloworld/hello HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31
</pre>
<p><b>Linha 4</b>: Esta linha descreve o <b>user agent</b> específico (navegador da web) que iniciou a comunicação fazendo um <b>request</b>(solicitação) para um recurso específico usando HTTP, descrito na linha 1.</p>

<p><b>Linha 2</b>: A solicitação feita pelo agente do usuário tem o formato mostrado como: <b>GET/olamundo/ola HTTP/1.1</b></p>
<br>
<ul>
 <li><b> GET -></b>O método http </li>
  <li><b>olamundo/ola -></b>O caminho(path) para o recurso no servidor web </li>
<li> <b>HTTP/1.1 -></b>A versão do protocolo que o navegado web está requisitando  </li>
</ul>
<p><i> Anatomia da Solicitação de Mensagem HTTP</i></p>
<br>
<p><b>Linha 3</b>: Esta máquina (sua máquina) que está executando um servidor Web é uma máquina servidor. Localhost é especificado onde você usaria o nome do host de um computador. Por exemplo, direcionar um navegador instalado em um sistema executando um servidor HTTP para http://localhost exibirá a página inicial do site instalado nesse sistema.</p>
<p> A página inicial do Tomcat que você verá quando iniciar o Tomcat em sua máquina executando <b>startup.bat</b> no diretório <b>bin</b> do Tomcat. Uma máquina servidor faz seus serviços disponível para a Internet usando portas numeradas, uma para cada serviço disponível no servidor. Por exemplo, se uma máquina servidor estiver executando um servidor web, ele normalmente estará disponível na porta 80 ou 8080 no caso do Tomcat.</p>
</section>
<section id="examrequest">
<h4>Examinando um solicitação</h4>
<p>
Quando o cliente (navegador da web) faz uma solicitação (uma solicitação GET nesse caso), o servidor da web (Tomcat) vê o caminho do recurso <b>/olamundo/ola</b> na solicitação na linha 2 e determina que o recurso solicitado pelo usuário não é um página estática (por exemplo, um arquivo .html) e encaminha a solicitação para o contêiner da web (Tomcat). O Tomcat desempenha o papel de servidor da web e do contêiner da web.</p>
<h4>Localizando o Servlet</h4>
<p>O caminho do recurso na solicitação  é mapeado para o servlet <b>OlaMundo</b> por meio do arquivo <b>web.xml</b>. Esse arquivo <b>web.xml</b> é chamado de descritor de implementação porque descreve o <b>servlet</b> implementado no contêiner da web. Por meio do descritor de implementação, o contêiner da web determina o servlet que precisa ser chamado para atender à solicitação HTTP original iniciada pelo navegador da web. O <b>web.xml</b> é mostrado novamente aqui.</p>
<pre class="brush:xml">
&lt?xml version="1.0" encoding="UTF-8"?>
&ltweb-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xmlns="http://xmlns.jcp.org/xml/ns/javaee"
 xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee 
 http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1">
&ltdisplay-name>olamundo&lt/display-name>
  
<servlet>
<servlet-name>OlaMundo</servlet-name>
<servlet-class>alpi.olamundo.OlaMundo</servlet-class>
</servlet>
<servlet-mapping>
<servlet-name>OlaMundo</servlet-name>
<url-pattern>/ola</url-pattern>
</servlet-mapping>
&lt/web-app>
</pre>

<p><b>Linhas 1 a 4</b>: essas linhas contêm XML padrão, indicando a versão, codificação e esquema usado para o arquivo XML.</p>
<p><b>Linhas 5 a 10</b>: A tag&ltservlet> é usada para configurar nosso servlet. Ele contém duas tags aninhadas: &ltservlet-name> define um nome lógico para o servlet e &ltservlet-class> indica a classe Java que define o servlet.</p>
<p><b>Linhas 11 a 14</b>: A tag XML &ltservlet-mapping> é usada para configurar nosso servlet. Ele contém duas tags aninhadas: &ltservlet-name> corresponde ao valor definido na tag &ltservlet> e &lturl-pattern> define o padrão de URL para o qual o servlet será executado.</p><br>

<p>Os aplicativos da web Java EE são executados a partir de uma raiz de contexto. A raiz de contexto é a primeira sequência na URL após o nome e a porta do servidor. Por exemplo, na URL <b>http://localhost:8080/olamundo/ola</b>, a string <b>olamundo</b> é a raiz do contexto(context root). O valor para &lturl-pattern> é relativo à raiz de contexto do aplicativo. </p>
<br>
<p>Um arquivo web.xml de Java EE pode conter muitas tags XML adicionais. Além de mapear URLs para servlets reais, você pode usar o descritor de implementação para personalizar outros aspectos do seu aplicativo da web, como funções de segurança, páginas de erro, bibliotecas de tags e informações de configuração inicial.
No entanto, essas tags adicionais não são necessárias para este aplicativo <b>olamundo</b>. O contêiner da Web carrega a classe de servlet <b>OlaMundo</b> e a instancia. Somente uma única instância do servlet <b>OlaMundo</b> é criada e solicitações simultâneas para o servlet <b>OlaMundo</b> são executadas nessa mesma instância.
Cada solicitação do cliente gera um novo par de objetos de solicitação e resposta. O contêiner executa vários encadeamentos para processar várias solicitações em uma única instância do servlet <b>OlaMundo</b>.</p>
</section>
<section id="ciclodevida">
<h3>Os métodos do ciclo de vida</h3>

<p>O ciclo de vida de um objeto descreve a sequência de etapas pelas quais um objeto deve passar durante sua existência. A vida de um servlet é diferente de uma classe Java normal porque um servlet precisa ser executado dentro do contêiner da web. A Figura mostra a hierarquia do servlet <b>OlaMundo</b>.</p>
<br>
<img src="imagens\jee7\ciclodevida.jpg">
<br>
</section>
<section id="genericserv">
<h4>GenericServlet</h4>
<p>A maioria dos servlets fornece funcionalidade básica semelhante por meio de uma classe abstrata <b>javax.servlet.GenericServlet</b> fornecida pela API do Servlet. A implementação da classe GenericServlet é independente de protocolo, portanto, não importa se é necessário responder a solicitações HTTP ou FTP. A classe abstrata GenericServlet define um método <b>init()</b> chamado pelo método <b>init(ServletConfig)</b> padrão para executar qualquer inicialização de servlet específica do aplicativo.</p>

</section>
<section id="httpserv">
<h4>HttpServlet</h4>
<p>Em um aplicativo Web, a falta de qualquer processamento dependente de protocolo em uma classe <b>GenericServlet</b> significa que o desenvolvedor precisa escrever o código para esse processamento em qualquer subclasse criada por ele. Como o HTTP é o protocolo mais conhecido e amplamente usado na Web, a API do Servlet também inclui mais uma subclasse abstrata de GenericServlet: <b>javax.servlet.http.HttpServlet</b>. O método <b>service()</b> é implementado pelo <b>HttpServlet</b>, que inspeciona o método HTTP recebido e chama o método apropriado para esse tipo de solicitação</p>
<br>
<p><i>O HTTP/1.1 define sete métodos de solicitação. A classe HttpServlet fornece implementações padrão para cada um desses métodos que você pode substituir em seus servlets. No entanto, a maioria dos aplicativos da Web inclui servlets que sobrescrevem apenas os métodos <b>doGet()</b> e <b>doPost()</b>.</i></p><br>

<p>Uma solicitação HTTP para uma subclasse HttpServlet passa por várias etapas:</p>

<ul>
<li>1. Uma chamada para o método de serviço público(ServletRequest, ServletResponse) pelo contêiner.</li>
<li>2. Delegação desta chamada ao serviço protegido do HttpServlet(HttpServletRequest, HttpServletResponse).</li>
<li>3. O serviço protegido (HttpServletRequest, HttpServletResponse) delegado ao método doXxx apropriado, dependendo do método HTTP usado para a solicitação.</li></ul>
	<br>
</section>
<section id="sevola">
	<h4>Servlet OlaMundo</h4>

	<p>Como mencionado na seção anterior, a superclasse do seu servlet inclui duas versões de init (), uma que usa um ServletConfig e outra que não aceita argumentos. O método init (ServletConfig) chama o no-arg init (), portanto, você precisa substituir apenas a versão no-arg
</p>
</section>
<section id="init">
<h4>Init()</h4>
<p>O contêiner chama init () na instância do servlet. Você pode substituí-lo para obter conexões de banco de dados registradas com outros objetos. Caso contrário, o método init () do servlet genérico será executado.</p>
<br>
<ul>
<li>1. Quando uma instância de servlet é criada, seu método init() é chamado. O método init() permite que um servlet se inicialize antes que a primeira solicitação seja processada. Você pode especificar parâmetros init() para o servlet no arquivo web.xml ou por meio de anotações.</li>
<li>2. O contêiner da Web chama o método init () do servlet (apenas uma vez na vida do servlet), e o método init () deve ser concluído antes que o contêiner possa chamar o método service()</li>
</ul>
<br>
</section>
<section id="services">
<h4>service()</h4>

<p>O contêiner chama o método service() do servlet. Esse método examina a solicitação, determina o tipo de método HTTP e chama o correspondente doGet() ou doPost() no servlet.
Você nunca o sobrescreve. Seu trabalho é sobrescrever doGet()ou doPost() e deixar a implementação do serviço do Servlet HTTP se preocupar em chamar o caminho certo</p>

<ul>
<li>1- Quando o método service() é chamado em seu servlet, serão entregues referências aos objetos HttpServletRequest e HttpServletResponse que implementam as interfaces HttpServletRequest e HttpServletResponse. O contêiner implementa essas interfaces.</li>
<li>2- Para cada solicitação recebida para o servlet, o método service() do servlet é chamado. Para as subclasses HttpServlet, um dos métodos doGet(), doPost() e assim por diante geralmente é chamado. O contêiner cria dois objetos:
HTTPServletRequest e HttpServletResponse.</li>
<li>3- O método service() pode ser chamado várias vezes, desde que o servlet esteja ativo no contêiner do servlet.</li>
<li>4- Os métodos service() chamam doGet()/doPost(). Você sempre substitui pelo menos um deles em seu servlet.</li>

</ul>
</section>
<section id="destroi">
<h4>destroy()</h4>
<p>O contêiner de servlet chama o método destroy() no servlet e esse método é chamado apenas uma vez. Este método fornece ao servlet a oportunidade de liberar recursos adquiridos antes de serem destruídos.</p>
</section>
<section id="servconfig">
<h4>ServletContext e ServletConfig</h4>
<p>Depois que o método <b>init()</b> é chamado, o servlet obtém um objeto <b>ServletConfig</b> por servlet e um <b>ServletContext</b> por aplicativo da web. Em um ambiente distribuído, você terá um ServletContext por JVM. Um ServletContext é um meio pelo qual um servlet pode se conectar ao contêiner e às outras partes do aplicativo da web. No servlet, a única vez que você precisará passar pelo <b>ServletConfig</b> para obter o <B>ServletContext</b> é se o servlet não for um <b>HttpServlet</b> ou um <b>GenericServlet</b>.</p>
<br>
<p>O objeto ServletConfig pode ser usado para fazer o seguinte:</p><br>
<ul>
<li>1- Passe informações de tempo de implementação para o servlet (como um nome de pesquisa de banco de dados ou enterprise bean) que você não deseja codificar no servlet. Essas informações em tempo de implementação são chamadas de parâmetros init do servlet. Os parâmetros init do servlet serão discutidos na próxima seção.</li>
<li>2- Acesse o ServletContext.</li>
</ul>
<br>

<p>O objeto ServletContext pode ser usado para fazer o seguinte:</p>
<br>
<ul>
<li>1- Acesse os parâmetros do aplicativo da web</li>
<li>2- Definir atributos que todos os componentes do aplicativo possam acessar.</li>
<li>Obtenha informações do servidor, incluindo o nome e a versão do contêiner e a versão da API suportada.</li>
</ul>
<br>
<p>Um servlet pode ter três tipos de parâmetros:</p><br>
<ul>
<li>Parâmetros de solicitação</li>
<li>Parâmetros de inicialização (init)</li>
<li>Parâmetros de inicialização de contexto(context-init)</li>
</ul>
<br>
</section>
<section id="parinit">
<h4>Parâmetros de Inicialização</h4>
<p>Os parâmetros de inicialização são definidos no arquivo web.xml, conforme ilustrado na Listagem abaixo:</p>

<pre class="brush:xml">
<servlet>
<init-param>
<param-name>email</param-name>
<param-value>gestaoti@alanpontoinfo.com.br</param-value>
</init-param>
</servlet>
</pre>

<p>Você não pode usar os parâmetros <b>init</b> até que o servlet seja inicializado. Seu servlet herda <b>getServletConfig()</b>, para que você possa chamar isso de qualquer método em seu servlet para obter uma referência a um <b>ServletConfig</b>. Depois de ter uma referência <b>ServletConfig</b>, você pode chamar <b>getInitParam()</b>.</p>

<br>
<p>Quando o contêiner inicializa um servlet, acontece o seguinte:</p><br>
<ul>
<li>1. O contêiner cria um ServletConfig exclusivo para o servlet.</li>
<li>2. O contêiner lê os parâmetros init do descritor de implementação e os define no objeto ServletConfig.</li>
<li>3. O contêiner passa o ServletConfig para o init do servlet(servletConfig).</li>
</ul>
<br>
</section>
<section id="paramcontext">
<h4>Parâmetros de contexto de Inicialização</h4>
<p>Os parâmetros de contexto de inicialização são semelhantes aos parâmetros de inicialização. A principal diferença entre os parâmetros context-init e os parâmetros init é que os parâmetros de contexto estão disponíveis para todo o aplicativo da Web, enquanto os parâmetros init estão disponíveis apenas para o servlet. O código abaixo ilustra os parâmetros context-init no arquivo web.xml.</p>

<pre class="brush:xml"> 
<context-param>
<param-name>email</param-name>
<param-value>gestaoti@alanpontoinfo.com.br</param-value>
</context-param>
</pre>
<p>O elemento &ltcontext-param> não está aninhado dentro do elemento &ltservlet >.</p><br>
<p>Como pegar o parâmento de contexto de inicialização:</p>
<pre class="brush:java">out.println(getServletContext().getInitParameter("email");</pre>
<p>Todo servlet herda um método <b>getServletContext()</b>. O método <b>getServletContext()</b> retorna um objeto <b>ServletContext</b>.</p>
</section>
<section id="requestdisp">
<h4>RequestDispatcher</h4>

<p>Em um aplicativo da web, há duas maneiras de alterar o fluxo de solicitações.</p><br>
<ul>
<li><b>Redirecionando a solicitação</b>: a solicitação é redirecionada para um URL completamente diferente.
O redirecionamento pode ser feito chamando <b>sendRedirect()</b> no objeto de resposta. O redirecionamento é feito pelo navegador.</li>
<li><b>Despachando a solicitação</b>: a solicitação é despachada para outro componente no aplicativo da web, geralmente uma página JSP. Um despacho de solicitação é diferente de um redirecionamento, pois faz o trabalho no lado do servidor. Um <b>RequestDispatcher</b> é chamado na solicitação e um redirecionamento é chamado na resposta.</li>
</ul>

<br>

<div style="overflow-x:auto;">
<table class="w3-table-all">
<tr><th>RequestDispatcher</th></tr>
<tr><td>forward(ServletRequest, ServletResponse)</td></tr>
<tr><td>include(ServletRequest, ServletResponse)</td></tr>
</table>
</div>
<br>

<p>Voce pode obter um <b>RequestDispatcher</b> em 2 maneiras:</p><br>
<ul>
<li>1- Obtendo RequestDispatcher de um ServletRequest</li>
<li>2- Obtendo um RequestDispatcher de um ServletContext</li>
</ul>
</section>
<section id="requestservlet">
<h4>Obtendo um RequestDipatcher de um ServletRequest</h4>
<pre class="brush:xml">RequestDispatcher view = request.getRequestDispatcher("bookDetails.jsp");</pre>

<p>O método <b>getRequestDispatcher()</b> em <b>ServletRequest</b> obtém um caminho para o recurso ao qual a solicitação está sendo encaminhada. Se o caminho começar com uma barra (/), será considerado pelo contêiner a partir da raiz do aplicativo Web. Se o caminho não começar com a barra, o contêiner o considerará relativo à solicitação original.</p>
</section>
<section id="restservcontext">
<h4>Obtendo um RequestDispacher de um ServletContext</h4>
<pre class="brush:java">RequestDispatcher view = getServletContext().getRequestDispatcher("/booDetails.jsp");</pre>
<p>O método <b>getRequestDispatcher()</b> usa um caminho String para o recurso ao qual você está encaminhando a solicitação. O RequestDispatcher, assim obtido do contexto ou solicitação, pode ser usado para encaminhar para o recurso porque o <b>RequestDispatcher</b> conhece o recurso para o qual você está encaminhando, em outras palavras, o recurso que foi passado como argumento para o <b>getRequestDispatcher()</b></p>

<pre class="brush:java">
RequestDispatcher view = request.getRequestDispatcher("bookDetails.jsp");
view.forward(request, response);
</pre>
</section>
<section id="filtros">
<h4>Filter</h4>
<p>Um filtro é um componente Java reutilizável que pode transformar o conteúdo de solicitações HTTP, respostas e informações de cabeçalho. Os filtros são usados ​​para o seguinte:</p>
<br>
<ul>
<li>1- Acessando conteúdo estático ou dinâmico ou modificando os cabeçalhos da solicitação antes de invocar uma solicitação</li> 
<li>2- Interceptando a chamada de um componente da Web após a chamada está invocada.</li>
<li> Fornecer acões nos componentes da web para usar uma cadeia de filtros em ordem específica.</li>
<li>Modificar o cabeçalho de resposta e  dados de resposta antes deles serem renderizados</li>
</ul>
<br>
<p>Um filtro é criado implementando a interface javax.servlet.Filter e fornecendo um construtor no-arg. Um filtro é configurado em um aplicativo Web, no descritor de implantação, usando o elemento <b>< filter ></b> ou na @WebFilterannotation (apresentada na seção a seguir). No elemento <b>< filter ></b>, você deve declarar o seguinte:</p>
<br>
<ul>
<li><b>&ltfilter-name></b>: usado para mapear o filtro para um servlet ou URL</li>
<li><b>&ltfilter-class></b>: usado pelo contêiner para identificar o tipo de filtro</li>
</ul>
<br>
<p><i>Você pode declarar o parâmetro de inicalização para um filtro</i></p>
<p><b>Declarando um filtro:</b></p>
<pre class="brush:xml">
<filter>
<filter-name>ResponseFilter</filter-name>
<filter-class>com.alpi.ResponseServlet</filter-class>
</filter>
</pre>
<p>Os filtros podem ser associados a um servlet usando o elemento <b>< servlet-name ></b>. A Listagem abaixo mapeia o filtro  <b>ResponseFilter</b> para o servlet <b>ResponseServlet</b>. </p>
<p><b>Mapeando o Filter para o Servlet:</b></p>
<pre class="brush:xml">
<filter-mapping> 
<filter-name>Response Filter</filter-name >
<servlet-name>ResponseServlet</servlet-name >
</filter-mapping>
</pre>
<p>Filtros podem ser associados com grupos de sevlets usando<b>&lturl-pattern></b>.</p>
<p><b>Associando um Filtro com um Grupo de Servlets</b></p>



<pre class="brush:xml">
<filter-mapping>
<filter-name>Response Filter</filter-name >
<url-pattern>/*</url-pattern >
</filter-mapping >
</pre>
<p>No exemplo acima, a resposta do filtro é aplicado para todos servlets no palicativo web.</p><br>
<p>Um aplicativo da web normalmente compreende os seguintes componentes de filtragem:</p>
<br>
<ul>
<li>Filtros de autenticação</li> 
<li>Filtros de cache </li>
<li>Filtros de compactação de dados</li> 
<li>Filtros de criptografia </li>
<li>Filtros de conversão de imagem </li>
<li>Filtros de registro e auditoria</li>
</ul>
<br>
</section>
<section id="vianotation">
<h3>Configurando Servlets via Anotações</h3>

<p>A partir do Servlet 3.0, os servlets podem ser configurados via web.xml ou usando anotações ou ambos.</p>
<p>A Tabela abaixo descreve as anotações suportadas por um contêiner da Web compatível com Servlet 3.0</p>
<br>
<div style="overflow-x:auto;">
<table class="w3-table-all">
<tr><th>Anotação</th><th>Descrição</th></tr>
<tr><td>@WebFilter</td><td>Define um filtro em um aplicativo web</td></tr>
<tr><td>@WebInitParam</td><td>Especifica os parâmetros init a serem passados ​​para o servlet ou o filtro</td></tr>
<tr><td>@WebListener</td><td>Anota um listener para obter eventos</td></tr>
<tr><td>@WeebServlet</td><td>Define um componente no aplicativo web</td></tr>
<tr><td>@MultipartConfig</td><td>Indica que a solicitação é do tipo mime/multipart</td></tr>
</table>
</div>
<br>
<p>Na seção a seguir, você desenvolverá um projeto <b>olamundo</b> no qual configurará o servlet por meio de anotações. Clique com o botão direito do mouse no projeto <b>olamundo</b>, crie uma nova classe de servlet e atribua o nome da classe como <b>OlaMundo</b>, conforme mostrado na Figura</p>
<br>
<img src="imagens\jee7\servletolamundo.jpg">
<br>
<p>Na próxima tela, você pode preencher as informações pertencentes ao descritor de implementação, como os parâmetros de inicialização e os mapeamentos de URL, conforme ilustrado na Figura abaixo. Para o aplicativo OlaMundo, você não precisa preencher os valores para os parâmetros de inicialização. O valor padrão do mapeamento de URL, neste caso /OlaMundo, está ótimo. Este valor no campo "Mapeamentos de URL" é o caminho do servlet do URL, conforme explicado na seção anterior. Clique em Avançar.</p>
<br>
<img src="imagens\jee7\olaservlet.jpg">
<br>
<p>Na próxima tela, especifique os modificadores, interfaces a serem implementadas e stubs de métodos a serem gerados, conforme ilustrado na próxima Figura . Marque <b>doGet</b> e <b>doPost</b> se ainda não estiverem marcados. Depois clique em Concluir.
</p>
<br>
<img src="imagens\jee7\dogetpost.jpg">
<br>
<p>A IDE gera o servlet OlaMundo como mostrado abaixo:</p>
<pre class="brush:java">
package alpi.olamundo;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class OlaMundo
 */
@WebServlet(description = "Um servlet Ola Mundo", urlPatterns = { "/OlaMundo" })
public class OlaMundo extends HttpServlet {
	private static final long serialVersionUID = 1L;
    
    /**
     * @see HttpServlet#HttpServlet()
     */
   public OlaMundo() {
        super();
        // TODO Auto-generated constructor stub
    }

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
	//response.getWriter().append("Served at: ").append(request.getContextPath());
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		//doGet(request, response);
	}

}
</pre>
<br>
<ul>
<li><b>Linha 13</b>: essa linha mostra o uso da anotação <b>@WebServlet</b>. O servlet <b>OlaMundo</b> é decorado com a anotação <b>@WebServlet</b> para especificar o nome, o padrão da URL, os parâmetros de inicialização e outros itens de configuração geralmente especificados no descritor deimplantação <b>web.xml</b>.</li>
<li><b>Linha 14</b>: Esta linha mostra que o servlet <b>OlaMundo</b> estende o Servlet HTTP.</li>
<li><b>Linhas 28 a 37</b>: essas linhas mostram os métodos <b>doGet</b> e <b>doPost</b> gerados pelo IDE.</li>
</ul>
<p>Adicione o código  ao método doGet do servlet <b>OlaMundo</b> para imprimir <b>Ola Mundo!</b></p>
<pre class="brush:java">
PrintWriter out = response.getWriter();
out.println("&lth2>Ola Mundo!&lt/h2>");
</pre>	

<p>Você precisará importar o <b>java.io.Printwriter</b>. Você pode fazer isso no Eclipse selecionando Source ->Add import ou pressionando Ctrl + Shift + M; agora você pode executar o aplicativo no servidor. Clique com o botão direito do mouse em <b>OlaMundo.java</b> no projeto <b>olamundo</b> no Eclipse e selecione Run As ➤Run on Server para executar no servidor. O servidor que você está usando neste caso é o Tomcat 8.0. Em seguida, use o seguinte URL para acessar o aplicativo:
</p>

<pre class="brush:html">http://localhost:8080/olamundo/OlaMundo</pre>
<br>
<img src="imagens\jee7\olamundotela.jpg">
<br>
<p>Para obter mais informações sobre a tecnologia Java Servlet, consulte a especificação Java Servlet 3.1  e o site Java Servlet.</p>
</section>
<section id="javaservepage">
<h4>Jaa Server Pages</h4>
<p>Servlets permitem que o servidor da Web gere conteúdo dinâmico. No entanto, os servlets têm uma grande desvantagem, pois é necessário que o código HTML seja conectado no código Java. Para eliminar esse cruzamento de preocupações, a tecnologia Java Server Pages(JSP) foi criada. O JSP usa uma combinação de conteúdo HTML estático e conteúdo dinâmico para gerar páginas da Web, separando assim a preocupação de incorporar o conteúdo HTML no código Java.
</p>
</section>
<section id="firstapp">
<h4> Primeiro Aplicativo Web Usando JSP </h4>

<p>Agora você criará um aplicativo "Ola Mundo " usando JSP. Desde que você criou um projeto com esse nome anteriormente, agora clique com o botãod direito em cima do projeto <b>olamundo</b> e crie um arquivo jsp na pasta padrão <b>WebContent</b> assim como mostra esta figura:</p>
<br>
<img src="imagens\jee7\jspfile.jpg">
	<br>
  Após criar o arquivo nomeie o projeto olamundo.jsp. Clique em seguir e finalize na proxima tela.</p>
<br>
<img src="imagens\jee7\olamundojsp.jpg">
<br>
<p>Modifique o código olamundo.jsp como mostrado a seguir:</p>
<pre class="brush:html">
&lt!DOCTYPE html>
&lthtml>
&lthead>
&ltmeta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
&lttitle>Ola Mundo</title >
&lt/head>

&ltbody>
Ola Mundo!
&lt/body>
&lt/html>

</pre>

<p> Em seguida implante esta aplicação no servidor, click com o botão direito em cima do arquivo <b>olamundo.jsp</b> e execute como servido cop mostra a figura:</p>
<br>
<img src="imagens\jee7\serverexe.jpg">
<br>
<p>Lance o aplicativo usando http://localhost:8080/olamundo/olamundo.jsp .</p>
<p>A Figura abaixo mostra como será a saída.</p>
<br>
	<img src="imagens\jee7\telaolamundo.jpg">
<br>
</section>
<section id="jspbasic">
	<h3>JSP Basico</h3>

	<p>Esta seção abordará as construções fundamentais do JSP. Uma boa compreensão da abordagem clássica é essencial para entender suas limitações e apreciar o poder de técnicas mais avançadas, como a <b>Expression Language</b>, que é um assunto do próximo capítulo. Antes de o <b>Expression Language</b> ser adicionado à especificação JSP, um bilhão de páginas JSP foram gravadas usando a abordagem clássica, e talvez você ainda precise mantê-las ou refatorá-las. Essa necessidade de compatibilidade com versões anteriores é uma das razões pelas quais a especificação JSP ainda cobre os componentes clássicos. Mas quando você precisar escrever novas JSPs em seu aplicativo, não deverá escrever código compatível com versões anteriores; em vez disso, você deve usar a abordagem de melhores práticas, que será explicada no próximo capítulo. Quando o JSP 1.0 foi adicionado à especificação do JSP em 1999, o objetivo era produzir conteúdo dinâmico baseado na Web, incorporando o código da lógica de negócios nos dados do modelo. Para esse fim, os seguintes elementos JSP foram fornecidos para serem usados ​​em uma página JSP para manipular objetos Java e executar operações sobre eles, permitindo assim a geração de conteúdo dinâmico.</p>
  </section>
  <section id="directivejsp">
	<h4>JSP Directives</h4>

	<p>As diretivas JSP são instruções para o contêiner JSP que são processadas durante o processo de conversão de página. As diretivas fornecem um mecanismo para disponibilizar informações no nível da página para o mecanismo JSP.</p>
<p>As diretivas são declaradas entre os delimitadores de diretiva <b><% @ e %></b> e têm o seguinte formato:</p>
<pre class="brush:html"><%@ directive {attribute="value"}* %> </pre>
</section>
<section id="pagedirective">
<h4>Page Directive</h4>

A diretiva page é usada para fornecer instruções sobre uma página JSP específica a ser usada pelo contêiner para gerar o servlet subjacente. A seguir, é apresentada a sintaxe básica da diretiva de página:</p>
<pre class="brush:html"><%@ page attribute="value" %></pre>

<p>A tabela  a seguir descreve os atributos associados coma diretiva page.</p><br>
<div style="overflow-x:auto;">
<table class="w3-table-all">
<tr><th>Atributo</th><th>Propósito</th></tr>
<tr><td>autoFlush</td><td>Controla o comportamento do buffer de saída do servlet. Indica se o buffer deve ser gravado automaticamente quando estiver cheio</td></tr>
<tr><td>buffer</td><td>Especifica o modelo de buffer para o fluxo de saída do servlet. Indica o tamanho do buffer</td></tr>
<tr><td>contentType</td><td>Especifica o tipo de MIME e o esquema de codificação de caracteres para a resposta.</td></tr>
<tr><td>errorPage</td><td>Especifica a URL de uma JSP que lida com as condições de erro e relata as exceções de tempo de execução</td></tr>
<tr><td>extends</td><td>Indica uma superclasse que o servlet gerado deve estender.</td></tr>
<tr><td>import</td><td>Especifica as classes para uso na página JSP semelhante à declaração de importação em Java.</td></tr>
<tr><td>info</td><td>Especifica uma sequência para o método getServletInfo() do servlet.</td></tr>
<tr><td>isELIgnored? isELEnabled</td><td>Especifica se a expressão EL é permitida na página JSP.</td></tr>
<tr><td>isErrorPage</td><td>Especifica se esta página JSP deve lidar com condições de erro e relatar exceções de tempo de execução</td></tr>
<tr><td>isScriptingEnabled</td><td>Especifica se os elementos de script são permitidos na página JSP
</td></tr>
<tr><td>isThreadSafe</td><td>Indica se a página JSP pode manipular solicitações simultâneas.</td></tr>
<tr><td>language</td><td>Indica a linguagem de script usada na página JSP</td></tr>
<tr><td>session</td><td>Especifica se a página JSP participa da sessão HTTP</td></tr>
</table>
</div>
<br>
</section>
<section id="includejsp">
<h4>Include Directive</h4>
<p>A diretiva include é usada para especificar recursos estáticos que devem ser incluídos na unidade de conversão de páginas JSP atual. O diretório incluído possui um atributo chamado arquivo que especifica a URL do recurso que deve ser incluído. A forma geral desta diretiva é a seguinte:
</p>

<pre class="brush:html"> &lt%@ include file="relative url"> </pre>

<p>O exemplo a seguir demonstra o uso da diretiva include para incluir um cabeçalho e rodapé JSP padrão na unidade de tradução atual. Você pode criar um projeto como sua primeira web
aplicativo, <b>olamundo</b> e substitua <b>olamundo.jsp</b> por <b>main.jsp</b>. A Listagem abaixo ilustra main.jsp.
</p>

<pre class="brush:html">
&lt%@ include file="header.jsp" %>

<p>content</p>

&lt%@ include file="footer.jsp" %>
</pre>
<ul>
<li><b>Linha 1</b>: essa linha inclui header.jsp no arquivo main.jsp no momento da tradução</li>
<li><b>Linha 5</b>: esta linha inclui footer.jsp no arquivo main.jsp no momento da tradução.</li>
</ul>
<br>
<p>A seguir o código header.jsp</p>
<pre class="brush:html">
&lthtml>
&lthead>&lt/head>
 &ltbody>
&lt%out.print("header"); %>
</pre>
<p>Linha 4: esta linha usa um objeto implícito. Objetos implícitos serão apresentados mais adiante neste capítulo. O objeto implícito <b>out</b> representa uma instância da classe <b>JspWriter</b> e é usado para gravar dados de caracteres no fluxo de resposta.</p>
<p>A seguir o código footer.jsp</p>
<pre class="brush:html">
<%out.print("footer"); %>
</body>
</html>
</pre>

<p>Logo abaixo a imagem da saída usando a diretiva include</p>
<br>
<img src="imagens\jee7\includedirect.jpg">
<br>
</section>
<section id="taglibdir">
<h4>TagLib Directive</h4>

<p>A API do Java Server Pages fornece ações padrão, abordadas na próxima seção, que encapsulam a funcionalidade. A API JSP também permite definir ações customizadas que implementam comportamento customizado.</p>
<p>Várias ações personalizadas, também chamadas de tags personalizadas, são montadas em uma biblioteca chamada biblioteca de tags.</p>
<p>A diretiva taglib é usada para definir um prefixo e um local para uma biblioteca de tags na página JSP atual.</p>
<p>A diretiva taglib usa a seguinte sintaxe:</p>

<pre class="brush:html"> &lt%@taglib uri="uri" prefix="tagPrefix"> </pre>

<p>O valor do atributo <b>uri</b> é um caminho absoluto ou relativo que especifica o local da biblioteca de tags e o atributo <b>prefix</b> especifica a ação customizada a ser usada no JSP atual. O código abaixo ilustra o uso da diretiva <b>taglib</b> para uma biblioteca de tags de exemplo chamada <b>olaTagLib</b>, que compreende uma tag chamada <b>ola</b> que imprime uma mensagem "Ola Mundo".</p>

<pre class="brush:html">
&lt%@ taglib uri="/olaTagLib" prefix="olaTag" %>
&lthtml >
&ltbody >
&ltolaTag:ola/>
&lt/body>
&lt/html>
</pre>
<ul>
<li><b>Linha 1</b>: O URI da biblioteca <b>olaTagLib</b> e o prefixo <b>olaTag</b><li>
<li> <b>Linha 4</b>: Usando a tag <b>ola</b> através do prefixo</li>
</ul>
<p> Esse arquivo acima que damos o nome <b>ola.jsp</b> precisa de uma classe para que esta mensagem chegue até ela e seja visualizado. O código abaixo mosrta como fazer esta classe:</p>
<pre class="brush:java">
package br.alpi.tagext;


import java.io.IOException;
import java.util.Date;
import javax.servlet.jsp.*;
import javax.servlet.jsp.tagext.*;

/**
*    Implementação de uma tag para gerar uma única peça de HTML.

*    @author    alansantos
*/
public class OlaTag extends TagSupport {

    /**
    *    Este método será chamado quando o mecanismo JSP encontrar o início
     * de uma tag implementada por esta classe
    */
    public int doStartTag() throws JspTagException {
        
          // Esse valor de retorno significa que o mecanismo JSP deve avaliar
         // o conteúdo e quaisquer tags filho dessa tag

        return EVAL_BODY_INCLUDE;
    }

    /**
    *    Este método será chamado quando o mecanismo JSP encontrar o final
     * de uma tag implementada por esta classe

    */
    public int doEndTag() throws JspTagException {
        String dateString = new Date().toString();
        try {
            pageContext.getOut().write("Ola Mundo.&ltbr/>");
            pageContext.getOut().write("O nome da classe é " + getClass().getName() +
                                        " e hoje é " + dateString + " &lt/p>");
        }
        catch (IOException ex) {
            throw new JspTagException("Fatal error: hello tag could not write to JSP out");
        }
       // Esse valor de retorno significa que o mecanismo JSP deve continuar a
         // avaliar o restante desta página
        return EVAL_PAGE;
    }
}    // classe OlaTag
</pre>
<br>
<p>Para que as <b>tag</b> funcione precisamos criar o arquivo .tld que daremos o nome de olaTagLib.tld. Esse arquivo fica na pasta <b>tlds</b> dentro de <b>WEB-INF</b>. O código deste arquivo veremos abaixo:</p>
<pre class="brush:xml">
&lt?xml version="1.0" encoding="UTF-8"?>
&lt!DOCTYPE taglib PUBLIC "-//Sun Microsystems, 
Inc.//DTD JSP Tag Library 1.1//EN" "http://java.sun.com/dtd/web-jsptaglibrary_1_1.dtd" >
<taglib>
<tlibversion> 1.0 </tlibversion>
  <jspversion>1.1</jspversion>
  <shortname>olaTag</shortname>
  <tag>
  <name>ola</name>
    <tagclass>br.alpi.tagext.OlaTag</tagclass>
    <bodycontent>JSP</bodycontent>
    <info>Simples exemplo</info>
   </tag>
</taglib>
</pre>
<p>Precisaremos também configurar o descriptor .xml que fica na pasta WEB-INF</p>
<pre class="brush:xml">
&lt?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE web-app PUBLIC '-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN' 
'http://java.sun.com/j2ee/dtds/web-app_2.2.dtd'>
&ltweb-app>
      <display-name>br.alpi.tagext</display-name>
  
  <description>Tag extensions examples</description>
  
  <session-config>
    <session-timeout>0</session-timeout>
  </session-config>
  
  <taglib>
    <taglib-uri>/olaTagLib</taglib-uri>
    <taglib-location>/WEB-INF/tlds/olaTagLib.tld</taglib-location>
  </taglib>

&lt/web-app>
</pre>
<p>Na figura  abaixo veja como fica a saida:</p>
<br>
<img src="imagens/jee7/tagolamundo.jpg">
<br>
</section>
<section id="declaracoes">
<h4>Declarações</h4>
<p>Usando declarações, o JSP permite declarar métodos e variáveis ​​nas páginas JSP. Quando estão em uma página JSP, ficam disponíveis para <b>scriptlets</b> e expressões em toda a página. As declarações JSP são colocadas entre delimitadores de declaração <%! e %>. </p>
</section>
<section id="expressao">
<h4>Expressão</h4>
<p>As expressões são semelhantes aos scriptlets, mas avaliam uma expressão Java regular e retornam um resultado, que é um String ou algo conversível em um String, para o cliente como parte da resposta. A sintaxe geral é a seguinte:</p>

<pre class="brush:java"><%= expression %></pre>
</section>
<section id="scriptlet">
<h4>Scriptlets</h4>

<p>Scriptlets são blocos de código Java entre os delimitadores <% e %> para criar conteúdo dinâmico. O código abaixo ilustra o uso de uma declaração com um scriptlet e expressão.</p>

<pre class="brush:java">
&lt%!
public String hello() {
String msg = "Hello World";
return msg;
}
%>
Message from &ltb>Scriptlet&lt/b>: <%hello();%>&ltbr/>
Message from &ltb>Expression&lt/b>: <%=hello() %>
</pre>
<ul>
<li><b>Linhas 1 a 6</b>: Essas linhas contêm uma declaração JSP que declara um método hello(). A linha 1 é a marca inicial e a linha 6 é a marca final da declaração.</li>
<li><b>Linha 7</b>: O método hello () declarado nas linhas 1 a 6 é usado em uma expressão na linha 7.</li>
</ul>

<p>A figura abaixo ilustra o uso declaração, scriptlets, e expressão.</p>
<br>
<img src="imagens\jee7\olascript.jpg">
<br>
</section>
<section id="objimplicito">
<h4>Objetos Implícito</h4>


<p>Em um aplicativo Web, vários componentes da Web colaboram entre si e compartilham informações por meio de objetos que são mantidos como atributos de quatro objetos de escopo. Você acessa esses atributos usando os métodos getAttribute e setAttribute da classe que representa o escopo. A Tabela abaixo lista os objetos do escopo.</p>

<div style="overflow-x:auto;">
<table class="w3-table-all">
<tr><th>Objetos de Escopo</th><th>Servlet API</th><th>Acessível de...</th></tr>
<tr><td>Application/ web contex</td><td>javax.servlet.ServletContext</td><td>Componentes da Web no aplicativo</td></tr>
<tr><td>Request</td><td>Subtype of javax.servlet.ServletRequest</td><td>Componentes da Web que manipulam a solicitação</td></tr>
<tr><td>Session</td><td>javax.servlet.http.HttpSession</td><td>Componentes da Web em uma sessão</td></tr>
<tr><td>Page</td><td>javax.servlet.jsp.JspContext</td><td>A página JSP que cria o objeto</td></tr>

</table>
</div>
<br>
<p>Uma página JSP pode acessar alguns objetos específicos por meio de variáveis ​​de script. Esses objetos são fornecidos pelo contêiner JSP e são chamados de objetos implícitos. Esses objetos implícitos podem ser acessados ​​em scriptlets, em expressões ou como parte das expressões EL.  A Tabela abaixo lista os nove objetos implícitos com a API correspondente.</p>
<br>
<div style="overflow-x:auto;">
<table class="w3-table-all">
<tr><th>Objeto Implicito</th><th>Uso</th><th>API</th></tr>	
<tr><td>application</td><td>Acessa objetos no nível do aplicativo</td><td>ServeletContex</td></tr>
<tr><td>config</td><td>Fornece informação de configuração</td><td>ServeletConfig</td></tr>
<tr><td>exception</td><td>Acessa status error</td><td>JSPException</td></tr>
<tr><td>out</td><td>Acessa o fluxo de saída do JSP</td><td>JSPWriter</td></tr>
<tr><td>page</td><td>Fornece uma referência para o JSP atual</td><td>Object</td></tr>
<tr><td>pageContext</td><td>Acessa o container JSP</td><td>PageContext</td></tr>
<tr><td>request</td><td>Fornece aceso para solicitação od cliente</td><td>ServletRequest</td></tr>
<tr><td>response</td><td>Fornece acesso para a Resposta do JSP</td><td>ServletResponse</td></tr>
<tr><td>session</td><td>Compartilhar informações através da solicitação do cliente</td><td>HttpSession</td></tr>
</table>
</div>
<br>
</section>
<section id="appbook">
<h4>Aplicativo</h4>

<p>O objeto implícito do aplicativo fornece uma referência à interface <b>javax.servlet.ServletContext</b>. A interface <b>ServletContext</b> é usada para fornecer acesso a quaisquer parâmetros de inicialização de contexto que foram configurados para a página JSP por meio do descritor de implementação do aplicativo da web. O objeto <b>ServletContext</b> e os parâmetros armazenados neles pelo contêiner da web estão disponíveis para todo o aplicativo da web. O objeto de aplicativo fornece ao desenvolvedor da página JSP acesso ao objeto <b>ServletContext</b>.</p>
</section>
<section id="config">
<h4>config</h4>
<p>Semelhante ao objeto de aplicativo, o objeto de configuração fornece uma referência à interface <b>ServletConfig</b> do aplicativo da web. A interface <b>ServletConfig</b> é usada para fornecer acesso a todos os parâmetros de inicialização que foram configurados para a página JSP por meio do descritor de implementação do aplicativo da web. O objeto de configuração fornece ao desenvolvedor JSP acesso ao objeto <b>ServletConfig</b>.</p>

</section>
<section id="exception">
<h4>exception</h4>
<p>O objeto de exceção implícito está disponível para JSP para manipular as condições de erro e relatar as exceções de tempo de execução usando a diretiva da página errorPage.
</p>
</section>
<section id="out">
<h4>out</h4>
<p>O objeto de saída implícito representa uma instância da classe JspWriter que é usada para gravar dados de caracteres no fluxo de resposta.</p>
</section>
<section id="page">
<h4>page</h4>
<p>O objeto implícito da página JSP é uma instância da classe Object e representa a página JSP atual.</p>
</section>
<section id="pagecontext">
<h4>pageContex</h4>
<p>Um pageContext fornece informações de contexto, fornecendo acesso a todos os namespaces associados a uma página JSP e a vários atributos da página. Além disso, ele contém a referência a objetos implícitos.</p>
</section>
<section id="requests">
<h4>request</h4>
<p>O objeto de solicitação é uma instância da interface <b>javax.servlet.http.HttpServletRequest</b>. Representa a solicitação do cliente. O objeto implícito da solicitação geralmente é usado para obter parâmetros, atributos da solicitação, informações do cabeçalho e valores string da consulta.</p>
</section>
<section id="response"></section>
<h4>response</h4>
<p>O objeto de resposta implícita é uma instância da interface <b>javax.servlet.http.HttpServletResponse</b> e representa a resposta a ser fornecida ao cliente. O objeto de resposta implícita é geralmente usado para definir o tipo de conteúdo da resposta, adicionar cookies e redirecionar a resposta.</p>
<section id="session">
  <h4>session</h4>
<p>O objeto implícito da sessão JSP é uma instância de uma classe Java que implementa a interface <b>javax.servlet.http.HttpSession</b>. É usado para armazenar o estado da sessão para um cliente.</p>
<p>O código abaixo ilustra o uso dos objetos implícitos frequentemente usados. Primeiro, mostra a tarefa comum de definir um atributo de book nos escopos de solicitação, sessão e aplicativo em um servlet. Em seguida, mostra seus equivalentes JSP.</p>


<pre class="brush:java">
getServletContext().setAttribute("book", book);
request.setAttribute("book", book);
request.getSession().setAttribute("book", book);
application.setAttribute("book" book);
request.setAttribute("book" book);
session.setAttribute("book" book);
pageContext.setAttribute("book" book);
</pre>

<ul>

<li><b>Linha 1</b>: define o atributo book em um ServletContext sem usar objetos implícitos.</li>
<li><b>Linha 2</b>: define o atributo book em um objeto de solicitação. O objeto de solicitação também é um objeto implícito no JSP. Portanto, a configuração do atributo em um servlet é semelhante à configuração do atributo em uma página JSP.</li>
<li><b>Linha 3</b>: define o atributo book na sessão sem usar objetos implícitos.</li>
<li><b>Linha 4</b>: define o atributo book no ServletContext usando o objeto implícito do aplicativo.</li>
<li><b>Linha 5</b>: define o atributo book em um objeto de solicitação. request também é um objeto implícito no JSP. Portanto, a configuração do atributo no JSP é semelhante à configuração do atributo em um servlet.</li>
<li><b>Linha 6</b>: define o atributo book na sessão usando um objeto implícito da sessão.</b>
<li><b>Linha 7</b>: define o atributo book no PageContext usando um objeto implícito pageContext. Não há equivalente a pageContext em um servlet. Uma instância PageContext fornece acesso a todos os espaços para nome associados a uma página JSP, fornece acesso a vários atributos da página e fornece uma camada acima dos detalhes da implementação. Objetos implícitos são adicionados automaticamente ao pageContext.</li>

</ul>
<br>
</section>

<section id="actionpd">
<h4>Ações padrão</h4>
<p>
As ações padrão do JSP fornecem uma maneira de fazer o seguinte:</p>
<br>
<ul>
<li>Manipular JavaBeans</li>
<li>Incluir arquivos dinamicamente</li>
<li>Executar encaminhamento de URL</li>
</ul>
<br>
</section>
<section id="actioninclude">
<h4>A acão &ltjsp:Include></h4>
<p>A ação <b>&ltjsp:include></b> fornece uma maneira de incluir em tempo de execução a diretiva para incluir o conteúdo de um componente da web separado na página JSP declarante. A sintaxe para usar a ação de inclusão padrão é a seguinte:
</p>

<pre class="brush:html">&ltjsp:include page="relativeURL" flush="true"/></pre>


<p>Vamos criar duas JSPs, para ilustrar o uso da ação <b>&ltjsp: include></b>.</p>

<pre class="brush:html">
<!--main.jsp-->
&lthtml>
&lthead>
&lt/head>
&ltbody>
&lt%out.print("Dentro de main.jsp"); %>&ltbr/>
&ltjsp:include page="sub.jsp"/>
&lt/body>
&lt/html>
</pre>

<pre class="brush:html">
<!--sub.jsp-->
&lthtml>
&lthead>
&lt/head>
&ltbody>
&lt%out.print("Dentro de sub.jsp"); %>&ltbr/>
&lt/body>
&lt/html>
</pre>
<br>
<img src="imagens\jee7\include.jpg">
<br>
<h4>A Ação <b>&ltjsp:forward></b></h4>
<p>A ação <b>&ltjsp: forward></B> é usada para encaminhar a solicitação atual para outro recurso, como uma página estática, uma página JSP ou um servlet. A sintaxe da ação é a seguinte:
</p>

<pre class="brush:html">&ltjsp:forward page="relativeURL" /></pre>

<p>Usaremos as duas JSPs criadas na seção anterior para ilustrar o uso da ação <b>< jsp: forward></b>. </p>

<pre class="brush:html">
&lthtml>
&lthead>
&lt/head>
&ltbody>
&lt%out.print("Dentro de main.jsp"); %>&ltbr>
&ltjsp:forward page="sub.jsp"/>
&lt/body>
&lt/html>
</pre>

<ul>
	<br>
<li> <b>Linha 6</b>:</li>  Usa < jsp: forward> para encaminhar para a página JSP de destino (sub.jsp).</li>
</ul>

<br>
<img src="imagens\jee7\forward.jpg">
<br>
<p>Para entender a diferença entre a ação include (inclusão) e a ação forward (encaminhamento), compare os dois ultimos exemplos e suas respectivas figuras. Em um usamos a ação forward(encaminhamento) no <b>main.jsp</b>, em vez da ação include (inclusão). A ação forward transfere o controle para <b>sub.jsp</b>, assim como a ação include. Mas quando <b>sub.jsp</b> é concluído, diferente da ação include, o controle não volta para <b>main.jsp</b>.</p>
</section>
<section id="actionsgeral">
<h4>As Ações &ltjsp:useBean>, &ltjsp:getProperty>, e &ltjsp:setProperty></h4>

<p>Essas três ações padrão podem eliminar uma grande quantidade de código de script, incluindo declarações, scriptlets e expressões.
</p>

<p>A ação <b>useBean</b> é usada para declarar e inicializar o objeto de bean. Depois que o bean é inicializado, você pode usar as ações <b>jsp: setProperty</b> e <b>jsp: getProperty</b> para definir e obter propriedades do <b>bean</b></p>

<p>A ação <b>&ltjsp: useBean></b> possui a seguinte sintaxe:</p>
<pre class="brush:html">&ltjsp:useBean id="algumID" class="AlgumaClass" /></pre>

<p>A ação <b>&ltjsp: setProperty></b> define as propriedades de um bean.</p><br>

<p>A ação <b>&ltjsp: setProperty></b> possui a seguinte sintaxe em que algumId é o ID do useBean:</p>

<pre class="brush:html">&ltjsp:setProperty name="algumId" property="algumProperty" .../></pre>

<p>A ação <b>&ltjsp:getProperty></b>, como o nome sugere, obtém o valor de uma determinada propriedade. Se a propriedade não for uma sequência, ela será convertida em uma string.</p><br>
<p>A ação <b>&ltjsp:getProperty></b> possui a seguinte sintaxe em que algumId é o ID do useBean:</p>
<pre class="brush:html">&ltjsp:getProperty name="algumId" property= "algumProperty" ... /></pre>
<p>O dois próximos exemplos mostra como criar um bean de usuário e mostra o uso dessas três ações em uma página JSP.</p>
<pre class="brush:java">
//User Bean

package com.alpi.jspactions;

public class User {

private String name;

public String getName() {
return name;
}

public void setName(String name) {
this.name = name;
}

}
</pre>

<p>O bean do usuário será usado em user.jsp que é mostrado logo abaixo.<p>
<pre class="brush:html">
<!--user.jsp-->
&lthtml>
&lthead>
&lt/head>
&ltbody>
&ltjsp:useBean id="user" class="com.alpi.jspactions.User"/>
&ltjsp:setProperty name="user" property="name" value="alan"/>
Hello&nbsp;&ltjsp:getProperty name="user" property="name"/>
&lt/body>
&lt/html>

</pre> 

<p>A Figura  mostra a saída quando o <b>user.jsp</b> é acessado.</p>
<br>
<img src="imagens\jee7\alanola.jpg">
<br>
</section>
<section id="padraomvc">
<h3>O Padrão MVC</h3>

<p>A motivação para o padrão Model-View-Controller(MVC) existe desde a concepção da programação orientada a objetos. Antes do MVC, o navegador acessava diretamente as páginas JSP. Em outras palavras, as páginas JSP tratavam diretamente das solicitações do usuário. Isso foi chamado de arquitetura Modelo-1, conforme ilustrado na Figura abaixo. Uma arquitetura do Modelo 1 exibia controle de aplicativo descentralizado, o que levou a uma camada de apresentação fortemente acoplada e quebradiça.</p>
<br>
<img src="imagens\jee7\padraomvc.jpg">
<br>
<p>Uma arquitetura do Modelo 2 para projetar páginas JSP é atualmente o padrão MVC aplicado aos aplicativos da web. O MVC se originou no Smalltalk e, desde então, chegou à comunidade Java.
A próxima Figura mostra a arquitetura do Modelo-2 (em outras palavras, MVC). No Modelo-2, um controlador lida com a solicitação do usuário em vez de outra página JSP. O controlador é implementado como um servlet.
As etapas a seguir são executadas quando o usuário envia a solicitação:</p>
<br>
<ul>
<li>1. O servlet do controlador lida com a solicitação do usuário.</li>
<li>2. O servlet do controlador instancia o JavaBeans apropriado com base na solicitação.</li>
<li>3. O servlet do controlador se comunica com a camada intermediária ou diretamente com o banco de dados para recuperar os dados necessários.</li>
<li>4. O controlador define o JavaBeans em um dos seguintes contextos: solicitação, sessão ou aplicativo.</li>
<li>5. O controlador envia a solicitação para a próxima visualização com base no URL da solicitação.</li>
<li>6. A exibição usa o JavaBeans da etapa 4 para exibir dados</li>
</ul>
<br>
<img src="imagens\jee7\mvc2.jpg">
<br>
</section>
<section id="bookstoreapps">
<h1>Aplicativo BookStore</h1>
<p> Anteriormente, desenvolvemos a camada de acesso a dados para o aplicativo BookStore e o consultamos com um aplicativo Java independente. Agora, substituiremos a camada Java independente por uma camada de apresentação. A camada de acesso a dados na parte inferior permanecerá a mesma,conforme ilustrado na figura.</p>
<br>
<img src="imagens\jee7\aplicativobook.jpg">
<br>

<p>Em um aplicativo pronto para produção, você também deve adicionar uma camada de serviço para lidar com a exceção do banco de dados. À medida que o aplicativo cresce, um aplicativo particionado mantém a separação de preocupações limpa. A Figura abaixo mostra a estrutura de diretórios do aplicativo BookStore.</p>

<br>
<img src="imagens\jee7\bookstore.jpg">
<br>
</section>
<section id="pginit">
<h3>A Página Inicial</h3>
<p>
A Figura abaixo mostra a página inicial do aplicativo. Ao inserir o URL (http://localhost: 8080/bookWeb/books), a página inicial exibe o menu, que consiste nas categorias dos livros disponíveis no banco de dados da livraria.</p>
<br>
<img src="imagens\jee7\paginainicial.jpg">
<br>
<p>A próxima Figura mostra a arquitetura MVC do aplicativo BookStore. Por uma questão de brevidade e compreensão de como as categorias são exibidas na página inicial, apenas os componentes relacionados à página inicial e às categorias são mostrados na figura.</p>
<br>
<img src="imagens\jee7\mvcbookstore.jpg">
<br>
<p>Na arquitetura MVC mostrada na Figura , M significa Categoria, V significa home.jsp e C significa BookController. O fluxo do aplicativo compreende seis etapas, conforme discutido nas seções a seguir.</p>
</section>
<section id="etapaum">
<h2>Etapa 1: Localizando o Servlet a partir da Solicitação</h2>

<p>A URL (http://localhost:8080/bookWeb/books) é para o conteúdo dinâmico; portanto, o servidor da Web encaminha a solicitação para o contêiner do servlet (Tomcat). O código abaixo ilustra o Deployment Descriptor.
</p>

<pre class="brush:xml">
&lt?xml version="1.0" encoding="UTF-8"?>
&ltweb-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns="http://java.sun.com/xml/ns/javaee" 
xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
id="WebApp_ID" version="3.0">
<display-name>bookWeb</display-name>
<servlet>
<servlet-name>BookServlet</servlet-name>
<servlet-class>br.com.alpi.bookweb.controller.BookController</servlet-class>
<init-param>
<param-name>base</param-name>
<param-value>/bookWeb/books</param-value>
</init-param>
<init-param>
<param-name>imageURL</param-name>
<param-value>/bookWeb/images</param-value>
</init-param>
<load-on-startup>1</load-on-startup>
</servlet>
<context-param>
<param-name>param1</param-name>
<param-value>/bookWeb/books</param-value>
</context-param>
<context-param>
<param-name>imageURL</param-name>
<param-value>/bookWeb/images</param-value>
</context-param>
<servlet-mapping>
<servlet-name>BookServlet</servlet-name>
<url-pattern>/books </url-pattern>
</servlet-mapping>
<welcome-file-list>
<welcome-file>index.html</welcome-file>
<welcome-file>index.htm</welcome-file>
<welcome-file>index.jsp</welcome-file>
<welcome-file>default.html</welcome-file>
<welcome-file>default.htm</welcome-file>
<welcome-file>default.jsp</welcome-file>
</welcome-file-list>
&lt/web-app>
</pre>
<ul>
	<li><b>Linha 32</b>: url-pattern / books é mapeado para o BookServlet no elemento < servlet-mapping>, que é mapeado para a classe de servlet BookController na linha 11.</li>
<li><b>Linhas 22 a 29</b>: especificamos parâmetros de contexto para o servlet no arquivo web.xml, pois os parâmetros de contexto estão disponíveis para o aplicativo Web inteiro. Quando uma instância de servlet é criada, seu método <b>init()</b> é chamado pelo contêiner de servlet.
O método <b>init()</b> permite que um servlet se inicialize antes que a primeira solicitação seja processada. Substituímos o método <b>init(ServletConfig config)</b> no <b>BookController</b> para obter as categorias do banco de dados do bookStore.
Essas categorias estarão disponíveis para todo o aplicativo. O <b>init(ServletConfig config)</b> sobrescrevendo no <b>BookController</b> é ilustrado no código abaixo.</li>
</ul>
</section>
<section id="etapa2e3">
<h2>Etapa 2 e Etapa 3: Acessando o banco de dados via DAO para obter as categorias do banco de dados e definindo as categorias no modelo.</h2>
<p> O código abaixo mostra o <b>BookController</b>.</p>
<pre class="brush:java">
public void init(ServletConfig config) throws ServletException {
super.init(config);
BookDAO bookDao = new BookDAOImpl();
// chamando o método DAO para recuperar bookList do banco de dados
List&ltCategory> categoryList = bookDao.findAllCategories();
ServletContext context = config.getServletContext();
context.setAttribute("categoryList", categoryList);
}
</pre>

<ul>

<li><b>Linha 5</b>: essa lista de categorias é obtida do banco de dados chamando findAllCategories() no objeto bookDao.</li>
<li><b>Linha7</b>: a lista de categorias é definida no <b>ServletContext</b> para que a lista esteja disponível para todo o aplicativo da web.</li>
</ul>
</section>
<section id="etapaquatro">
<h2>Etapa 4: Despachando para a visualização</h2>

<p>Como o método <b>init()</b> é concluído na etapa anterior, o contêiner chama o método <b>service()</b> do servlet (discutido nos métodos de servlet de ciclo de vida). Este método examina a solicitação, determina o método HTTP e chama o <b>doget()</b> ou <b>dopost()</b> correspondente no servlet. O código ilustra os métodos <b>doGet()</b> e <b>doPost()</b> do servlet.</p>
<pre class="brush:java">
protected void doGet(HttpServletRequest request,
HttpServletResponse response) throws ServletException, IOException {
doPost(request, response);
}

protected void doPost(HttpServletRequest request,
HttpServletResponse response) throws ServletException, IOException {
String base = "/jsp/";
String url = base + "home.jsp";
String action = request.getParameter("action");
String category = request.getParameter("category");
String keyWord = request.getParameter("keyWord");
if (action != null) {
switch (action) {
case "allBooks":
findAllBooks(request, response);
url = base + "listOfBooks.jsp";
break;
case "category":
findAllBooks(request, response);
url = base + "category.jsp?category=" + category;
break;
case "search":
searchBooks(request, response, keyWord);
url = base + "searchResult.jsp";
break;

}
}
RequestDispatcher requestDispatcher = getServletContext()
.getRequestDispatcher(url);
requestDispatcher.forward(request, response);
}
</pre>
<br>
<ul>
<li><b>Linha 3</b>: O método <b>doPost()</b> é chamado do método <b>doGet()</b>.</li>
<li><b>Linha 9</b>: essa linha constrói o URL que aponta para a exibição da página inicial (home.jsp).</li>
<li><b>Linha 10</b>: esta linha obtém o parâmetro de ação da solicitação. Mas como essa é uma página inicial, não há parâmetro de ação associado; portanto, a ação variável é nula.</li>
<li><b>Linhas 13 a 29</b>: o bloco de código das linhas 13 a 29 é ignorado, pois a ação é nula. Se a ação não fosse nula, o URL teria sido reconstruído para apontar para uma visualização diferente, dependendo se o valor da ação é allBooks ou categoria ou pesquisa.</li>
<li><b>Linha 32</b>: O <b>RequestDispatcher</b> encaminha para o nome da exibição no URL na linha 31.</li>
</ul>
</section>
<section id="etapa5">
<h3>Etapa 5: Acessando o modelo da visualização</h3>

<p>Na etapa anterior, o controlador encaminha para o modo de visualização <b>home.jsp</b> usando o <b>RequestDispatcher</b>.</p>
<p>O próximo código ilustra um fragmento de <b>home.jsp</b>, que inclui <b>leftColumn.jsp</b>. O arquivo <b>leftColumn.jsp</b> usa o modelo <b>Category</b> para exibir categorias no menu esquerdo da página inicial.</p>
<p><b>Incluindo leftColumn.jsp em home.jsp</b></p>
<pre class="brush:html">
&ltbody>
&ltdiv id="centered">

&ltjsp:include page="header.jsp" flush="true"/>
&ltbr>
&ltjsp:include page="leftColumn.jsp" flush="true"/>
&ltspan class="label">Featured Books&lt/span>
..........
&lt/div>
&lt/body>
</pre>
<p><b>Linha 6</b>: a <B>tag&ltjsp: include></b> é usada para incluir <b>leftColumn.jsp</b>. Isso é feito porque a barra do lado esquerdo do aplicativo (o menu) é comum a todas as telas do aplicativo, mas, em vez de gravar a barra do lado esquerdo em todas as telas, nós a escrevemos em uma página JSP e a incluímos sempre que necessário como um meio de reutilização.
</p><br>
<p>O código abaixo ilustra o fragmento de código relacionado às categorias no <b>leftColumn.jsp</b> onde a categoria é acessada.</p>
<p><b>Acessando o modelo de categoria em leftColumn.jsp</b></p>
<pre class="brush:html">

&ltli>
 &ltdiv>&ltspan class="label" style="margin-left: 15px;">Categories&lt/span>
 &lt/div>
&ltul>
&lt%
List&ltCategory>categoryList1 = (List&ltCategory>) application.getAttribute("categoryList");
Iterator&ltCategory> iterator1 = categoryList1.iterator();
while (iterator1.hasNext()) {
Category category1 = (Category) iterator1.next();%>
&ltli> &lta class="label" href="<%=param1%>?action=category&categoryId=<%=category1.
getId()%>&category=<%=category1.getCategoryDescription()%>">&ltspan class="label" style="margin-left: 
30px;"><%=category1.getCategoryDescription()%>&lt/span>&lt/a>
&lt/li>
<%}%>
&lt/ul>&lt/li>
</pre>

<p><b>Linha 4</b>: nesta linha, a lista de categorias é obtida no <b>ServletContext</b>. Salvamos a lista de categorias no <b>ServletContext</b>, obtida a partir do
banco de dados na etapa 2.</p>
<p><b>Linha 6 a 10</b>: Os detalhes da categoria são exibidos na marcação, como a descrição da categoria que você vê na página inicial.</p>
<br>
<p><i>A página JSP <b>leftColumn.jsp</b> usa <b>scriptlets</b> e expressões para obter as categorias e exibi-las.
O uso de scriptlets e expressões são práticas inadequadas e devem ser evitadas o máximo possível. Mais adiante mostraremos como substituir scripts e expressões por <b>JSTL</b> e <b>EL</b></i>.</p>
</section>
<section id="etapa6">
<h3>Etapa 6: Enviando a Resposta </h3>

<p>A visualização construída na etapa anterior é entregue ao navegador.</p><br>
<h4>Listando todos os Livros</h4>
<p>Quando o usuário clica em <b>AllBooks</b> no menu, a lista de todos os livros é exibida, conforme ilustrado na Figura abaixo.</p>
<br>
<img src="imagens\jee7\respostabook.jpg">
<br>
<p>
O link <b>AllBooks</b> está no arquivo <b>leftColumn.jsp</b>. O próximo código ilustra o fragmento de código para o link <b>AllBooks</b> no menu.</p>
<pre class="brush:html">
&ltli>&ltdiv>
&lta class="link1" href="<%=param1%>?action=allBooks">
&ltspan style="margin-left: 15px;" class="label">All Books&lt/span>&lt/a>
&lt/div>&lt/li>
</pre>
<br>
<ul>
<li><b>Linha 2</b>: esta linha é o link AllBooks exibido no menu. Quando esse link é clicado, o valor de action-allBooks é adicionado à URL como parâmetro, conforme mostrado na URL:</li>
<li>http:localhost:8080/bookWeb/books?action=allBooks</li>
</ul>
<br>
<p>A etapa 2, que está localizando o servlet a partir da solicitação, é executada, mas desta vez a ação não é nula e tem um valor allBooks. Portanto, o bloco de código no método <b>doPost()</b> no <b>BookController</b>, mostrado a seguir , é executado.</p>

<pre class="brush:java">
protected void doPost(HttpServletRequest request,
HttpServletResponse response) throws ServletException, IOException {
String base = "/jsp/";
String url = base + "home.jsp";
String action = request.getParameter("action");
String category = request.getParameter("category");
String keyWord = request.getParameter("keyWord");
if (action != null) {
switch (action) {
case "allBooks":
findAllBooks(request, response);
url = base + "listOfBooks.jsp";
break;
case "category":
findAllBooks(request, response);
url = base + "category.jsp?category=" + category;
break;
case "search":
searchBooks(request, response, keyWord);
url = base + "searchResult.jsp";
break;

}
}
RequestDispatcher requestDispatcher = getServletContext()
.getRequestDispatcher(url);
requestDispatcher.forward(request, response);
}
</pre>

<ul>
<li><b>Linha 8</b>: a ação não é nula e o valor da ação é allBooks.</li>
<li><b>Linhas 10 a 12</b>: O método auxiliar <b>findAllBooks(request, response)</b> é chamado, a URL é reconstruída para apontar para <b>listOfBooks.jsp</b> e o <b>RequestDispatcher</b> encaminha para a exibição fornecida ao <b>RequestDispatcher</b> no formato de uma URL.</li>
</ul>
<br>
<p>O código seguinte mostra o método auxiliar <b>findAllBooks(request, response)</b> no <b>BookController</b>.</p>

<pre class="brush:java">
private void findAllBooks(HttpServletRequest request,
HttpServletResponse response) throws ServletException, IOException {
try {
BookDAO bookDao = new BookDAOImpl();
List&ltBook> bookList = bookDao.findAllBooks();
request.setAttribute("bookList", bookList);

} catch (Exception e) {
System.out.println(e);
}
}
</pre>
<br>
<ul>
<li><b>Linhas 5 a 6</b>: Esta lista de todos os livros é obtida do banco de dados usando o método <b>findAllBooks()</b> no <b>DAO</b> e é definida como um atributo na solicitação.
</li>
</ul>
</br>
<section id="pesquisarlivro">
<h2>Pesquisando Livros por Categoria</h2>
<p>Quando o usuário clica em uma categoria específica no menu, a lista de livros nessa categoria é exibida, conforme ilustrado na Figura abaixo.</p>
<br>
<img src="imagens\jee7\categorylist.jpg">
<br>
<p>Vimos na seção anterior que as categorias estão em leftColumn.jsp. A seguir ilustramos o fragmento de código da categoria.</p>

<pre class="brush:html">
<li>
&lta class="label" href="<%=param1%>?action=category&categoryId=<%=category1.
getId()%>&category=<%=category1.getCategoryDescription()%>">&ltspan class="label" 
style="margin-left: 30px;"><%=category1.getCategoryDescription()%>&lt/span>&lt/a>
</li>
</pre>

<ul>

<li><b>Linha 2</b>: este é o link da categoria exibida no menu. Quando esse link é clicado, o ID da categoria e a descrição e o nome da categoria de ação são adicionados ao URL como parâmetro, conforme mostrado no seguinte URL:</li>
<li>http://localhost:8080/bookWeb/books?action=category&categoryId=4&category=Scala</li>
</ul>
<br>

<p>Novamente, a etapa 2, que está localizando o servlet a partir da solicitação, é executada e, desta vez, a ação não é nula e possui uma categoria de valor. Portanto, o bloco de código no método <b>doPost()</b> no <b>BookController</b> é executado.</p>

<pre class="brush:java">
protected void doPost(HttpServletRequest request,
HttpServletResponse response) throws ServletException, IOException {
String base = "/jsp/";
String url = base + "home.jsp";
String action = request.getParameter("action");
String category = request.getParameter("category");
String keyWord = request.getParameter("keyWord");
if (action != null) {
switch (action) {
case "allBooks":
findAllBooks(request, response);
url = base + "listOfBooks.jsp";
break;
case "category":
findAllBooks(request, response);
url = base + "category.jsp?category=" + category;
break;
case "search":
searchBooks(request, response, keyWord);
url = base + "searchResult.jsp";
break;

}
}
RequestDispatcher requestDispatcher = getServletContext()
.getRequestDispatcher(url);
requestDispatcher.forward(request, response);
}
</pre>
<br>

<ul>
<li><b>Linha 8</b>: a ação não é nula e o valor da ação é categoria.</li>
<li><b>Linhas 15 a 16</b>: O método auxiliar findAllBooks(request, responsa) é chamado, o URL é reconstruído para apontar para <b>listOfBooks.jsp</b> e o <B>RequestDispatcher</b> encaminha a visualização fornecida ao <b>RequestDispatcher</b> na forma de um URL.</li>
</ul>
<p> O código a seguir mostra o método auxiliar findAllBooks(request, response) no BookController.</p>
<pre class="brush:java">
private void findAllBooks(HttpServletRequest request,
HttpServletResponse response) throws ServletException, IOException {
try {
BookDAO bookDao = new BookDAOImpl();
List< Book> bookList = bookDao.findAllBooks();
request.setAttribute("bookList", bookList);

} catch (Exception e) {
System.out.println(e);
}
}
</pre>
</section>
<section id="pesporchave">
<h2>Pesquisando os Livros por Palavra Chave</h2>

<p>Você pode pesquisar os livros pelo nome do autor ou por uma palavra-chave no título do livro, conforme ilustrado na Figura abaixo.</p>
<br>
<img src="imagens\jee7\pesquisabook.jpg">
<br>
<p>Antes de falarmos sobre o funcionamento da pesquisa por palavra-chave, vamos primeiro analisar um aspecto da usabilidade da pesquisa. Há um ponto de interrogação ao lado do campo de pesquisa, que serve para ajudar o usuário. Em outras palavras, ao passar o mouse, é mostrada uma dica de ferramenta que indica os parâmetros de pesquisa a serem usados, conforme ilustrado na Figura abaixo.</p>
<br>
<img src="imagens\jee7\tooltip.jpg">
<br>
<p>Para entender como a dica de ferramenta funciona, dê uma olhada na marcação do campo de pesquisa, que está em leftColumn.jsp, conforme ilustrado no código a seguir</p>

<pre class="brush:html">
&ltform class="search">
&ltinput type="hidden" name="action" value="search" />
&ltinput id="text"type="text" name="keyWord" size="12" />
&ltspan class="tooltip_message">?&lt/span>

&ltinput id="submit" type="submit" value="Search"/>
&lt/form>
</pre>
<br>
<ul><li><b>Linha 4</b>: possui uma classe tooltip_message. A dica de ferramenta funciona usando jQuery e CSS nesta classe.</li></ul>

<br>
<p>A seguir é mostrado código jQuery ToolTip: </p>
<pre class="brush:html">
$(document).ready(function () {
$("span.tooltip_message").hover(function () {
$(this).append('&ltdiv class="message">&ltp>Search by Keyword in:&ltul>&ltli>Author First Name &lt/li> 
&ltli>Author Last Name &ltli>Title of the book &lt/li>&lt/ul>&lt/p>&lt/div>');
},function () {
$("div.message").remove();
});
7.});
</pre>

<br>
<ul>
<li><b>Linha 2</b>: a classe tooltip_message a tag< span> são usadas como um seletor no qual a função de foco é chamada.</li>
<li><b>Linha 3</b>: a mensagem a ser exibida na dica de ferramenta é anexada ao objeto retornado pelo seletor na linha 2.</li>
</ul>
<br>
<p>Da mesma maneira, uma dica de ferramenta pode ser adicionada às imagens na tela inicial, conforme ilustrado na Figura abaixo.</p>
<br>
<img src="imagens\jee7\tooltipimage.jpg">
<br>
<p><b>Função jQuery para Tooltip Imagem</b></p>
<pre class="brush:html">
$("span.tooltip_img1").hover(function(){$(this).append('&ltdiv class="message">&ltul> 
&ltli>Title - Beginning Groovy, Grails and Griffon&lt/li>&ltli>Author: Vishal Layka&lt/li> 
&ltli>Publisher: Apress&lt/li>&lt/ul>&lt/div>');
}, function(){$("div.message").remove();});
</pre>

<p>A seguir mostramos o código CSS para o tooltip.</p>
<pre class="brush:css">
span.tooltip_message,span.tooltip_img1 {
cursor: pointer;
display: inline-block;
background-color: #F20B26;
width: 16px;
height: 18px;
color: #ffffff;
font-size: 12px;
font-weight: bold;
text-align: center;
position: relative;
}

span.tooltip_message:hover {
background-color: #04FF97;
}

div.message {
background-color: #04FF97;
color: #000000;
position: absolute;
left: 18px;
top: -18px;
z-index: 1000000;
text-align: left;
width: 280px;
}
</pre>

<p>Esses códigos CSS e jQuery  estão incluídos no leftColumn.jsp, conforme ilustrado no código a seguir:</p>
<pre class="brush:html">
&ltlink rel="stylesheet" href="css/bookstore.css" type="text/css"/>
&ltscript src="js/bookstore.js" type="text/javascript">&lt/script>
&ltscript type="text/javascript" src="js/jquery-1.9.1.js">&lt/script>
</pre>
<br>
<ul>
<li><b>Linha 1</b>: este é o arquivo CSS externalizado </li>
<li><b>Linha 2</b>: este é o arquivo JavaScript externalizado para a função jQuery.</li>
<li><b>Linha 3</b>: a linha 3 especifica a biblioteca jQuery que estamos usando.</li>
</ul>
<bR>

	<p>Agora começaremos com a funcionalidade de pesquisa por palavra-chave em nosso aplicativo da web. O código a seguir ilustra a marcação do campo de pesquisa.</p>

<pre class="brush:html">
&ltform class="search">
&ltinput type="hidden" name="action" value="search" />&ltinput id="text"
type="text" name="keyWord" size="12"/>&ltspan
class="tooltip_message">?&lt/span>

&ltinput id="submit" type="submit" value="Search"/>
&lt/form>
</pre>
<br>
<ul>
<li>Linha 2: esta linha especifica a pesquisa do valor da ação.</li>
<li>Linha 6: esta linha envia a solicitação.</li>
</ul>

<br>

<p>Quando o usuário envia a solicitação de pesquisa(novamente, localizando o servlet a partir da solicitação), a etapa 2 é executada e, desta vez, a ação possui uma pesquisa de valor. Portanto, o caso de pesquisa no método <b>doPost()</b> no <b>BookController</b>, mostrado no código seguinte, é executado.</p>

<pre class="brush:java">
protected void doPost(HttpServletRequest request,
HttpServletResponse response) throws ServletException, IOException {
String base = "/jsp/";
String url = base + "home.jsp";
String action = request.getParameter("action");
String category = request.getParameter("category");
String keyWord = request.getParameter("keyWord");
if (action != null) {
switch (action) {
case "allBooks":
findAllBooks(request, response);
url = base + "listOfBooks.jsp";
break;
case "category":
findAllBooks(request, response);
url = base + "category.jsp?category=" + category;
break;
case "search":
searchBooks(request, response, keyWord);
url = base + "searchResult.jsp";
break;

}
}
RequestDispatcher requestDispatcher = getServletContext()
.getRequestDispatcher(url);
requestDispatcher.forward(request, response);
}
</pre>
<br>
<ul>
<li><b>Linha 18</b>: a pesquisa de caso é executada e o valor da ação é pesquisa.</li>
<li><b>Linha 19</b>: O método searchBooks() é chamado. O código searchBooks() é ilustrado a seguir.</li>
<li><b>Linha 20</b>: a linha 20 constrói o URL da exibição.</li>
<li><b>Linha 26</b>: o URL da exibição é fornecido ao RequestDispatcher.</li>
</ul>
<br>
<p>O código do método auxiliar searchBooks() usado pelo controlador para chamar a chamada no DAO é mostrado a seguir.</p>

<pre class="brush:java">
private void searchBooks(HttpServletRequest request,
HttpServletResponse response, String keyWord)
throws ServletException, IOException {
try {
BookDAO bookDao = new BookDAOImpl();
List&ltBook> bookList = bookDao.searchBooksByKeyword(keyWord);

request.setAttribute("bookList", bookList);

} catch (Exception e) {
System.out.println(e);
}
}

</pre>
<ul>
<li><b>Linha 6</b>: obtém o bookList com base na palavra-chave de pesquisa, invocando o método <b>searchBooksByKeyword()</b> definido no <b>BookDAO</b>. Usamos esse método quando construímos a camada de acesso a dados para nosso aplicativo da web.</li>
</ul>
<br>
<p class="nav-arq" id="referencia"> Localização<a href="localization.html">&laquo; anterior | <a href="mlpraticasjee.html">próximo >> Melhores Praticas Java EE &raquo;</a> </p>
<div class="rodape"><p style ="tex-align:center"><a href="https://github.com/alanpontoinfo/javanis/tree/master/javacodigos/jeeservlet" target="_blank" >ACESSE OS CÓDIGOS NO REPOSITÓRIO GITHUB</p><img src="imagens/github.png"/></a></div>
</div>
</div>

  
</body>
</html>