
<!DOCTYPE html>
 <html lang="pt-br">
 <head>
 <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" >

  <link rel="stylesheet" type="text/css" href="css/stylos.css">
 <title> Programar em Java</title>
 </head>
 <body>
<div class="conteudo">
  <h1>APRENDENDO PROGRAMAR EM JAVA</h1>
  <h2>Apresentação</h2>
  <p>Olá ! Bem vindo(a)s! Estou criando este conteúdo com intuito de fornecer conhecimento 
em uma tecnologia que está entre as mais usadas no mundo.</p><br>
<p>Com Java você pode criar inúmeras aplicações para web, desktop, mobile, webservices e mais 
uma infinidade de coisa.</p><br>
<p>Mas como todo conhecimento para ser adquirido tem que ser iniciado, esse espaço é pra você 
que pensa em certificar-se em java e já deu os primeiros passos ou que quer somente aprender
 uma tecnologia pra desenvolver suas idéias.</p>

<p>Este projeto será desenvolvido em 03 partes: </p><br>
<p>
1º->Entendendo a estrutura java - Entendendo Operadores em java (Concluído)<br>
2º->APIs Java - Metodos e Encapsulamento (futuro)<br>
3º->Desenho da Classe e Excessões(futuro)<br>
</p>
<br>
<p>Nesta primeira parte o objetivo é aprender o básico, como:</p>
<p>
<ul>
<li>Definir o Escopo de variáveis</li>
<li>Definir a estrutura de um classe Java</li>
<li>Criar aplicaçoes java executávelcom um metodo main;</li>
<li>Executar um programa java da linha de comando; incluindo saída no console.</li>
<li>importar outros  pacotes java para fazê-los acessíveis em seu código</li>
<li>Declarar e inicializar variáveis(incluindo cast ou tipos primitivos).</li>
<li>Diferenciar entre variáveis de referência  e variáveis primitivas</li>
<li>Conhecer como ler e/ou escrever para campos do objeto  </li>
<li>Ciclo de vida do Objeto e coletores de lixo;</li>
<li>Usar Operadores java; inculindo parenteses para sobrepor precedência de operadores;</li>
<li>Criar if e if/else e construtores ternário</li>
<li>Usar uma declaração switch</li>
<li>Criar e usar while loops</li>
<li>Criar e usar for loops incluindo for-each</li>
<li>Criar e usar do/while loops</li>
<li>Usar break e continue</li>
</ul>
</p>
<p>Pra se ter um melhor nível de aprendizado é recomendável que não comece com uma Ide do tipo Eclipse ou Netbeans
Comece utilizando bloco de notas e execute utilizando linhas de comando:</p>
<p> <b>-"javac <nomedoprograma>.java" pra compilar e "java<nomedopragrama>"" pra executar</b></p><br>
<p>Estes comandos podem ser utilizado no seu sistema operacional linux, windows, e outros independentemente!
Pois java tem uma máquina virtual que cuida de todo o programa.</p><br>
 <p>Pra utilizar estes comandos crie uma pasta e coloque seus códigos dentro, depois acesse via shell
promptDos se for windows, git bash no linux e outros.</p><br>
<p>Este  reconhece que você ao menos tem conhecimento de instalação do java e já teve algum contato
com lógica de programação e sabe acessar a linha de comando.</p>
 
<p>Esse conteúdo é baseado no livro Certified Associate Java SE 8 Programmer I<br>
Um guia de estudo para o exame 1z0-808.<br>
Boa Leitura!</p>
 
 <br>
<h1>1-ENTENDENDO A ESTRUTURA JAVA</h1>
<p>No programa Java, classes são básicos construtores de blocos. Quando define uma classe, você descreve todas as partes e características 
destes construtores de blocos. Para usar mais classes, você tem que criar objetos. </p>
<p>Um objeto é uma instância de uma classe em memória no tempo de execução.
Todos os vários objetos de todas as diferentes classes representa o estado de seu programa.</p> 
<br>
<p><b>Class Arvore{}</b></p>
<br>
<h2>Campos e métodos</h2>
<p>As variáveis são conhecidas como campo é é o que aguarda o estado do programa.
Métodos são conhecios como função ou procedimentos em outras linguagens. Juntos são chamados de membros da classe.</p>
<pre>
1-public class Arvore{
2-private string nome;
3-public String getNome(){
4-return nome;
5-}
6-public void setNome(String novoNome){
7-nome=novoNome;
8-}
9-}
</pre>
<ul>
<li>1- Cria um classe que pode ser pública e não pública</li> 
<li>2- Declara variável como privada (significa que sua variável só é acessível ao membro desta classe)</li> 
<li>3-5 Define o primeiro método. Um método é uma operação que pode ser chamado e o nome <b>public</b> significa
 que este método pode ser chamado de outras classes.</li>
<li>Este vem com um tipo de retorno . Neste caso o método retorna uma <b>String.</b></li>
<li>6-8 Outro método. Esse tem um tipo de retorno especial chamado <b>void</b>. Void significa que nenhuma valor neste é retornado.</li>
<li>Este método requer que informações que sejam fornecidas para ele a partir do método de chamada</li>
<li>Esta informação é chamada de parâmetro. <b>setNome</b> tem um parâmetro nomeado <b>novoNome</b>, e é um tipo de <b>String</b>.</li>
<li>Isto siginifica que o chamador devera passar um parâmetro <b>String</b> e esperar nada ser retornado.</li>
</ul>
<h2>Comentários</h2>
<p>Os comentário em java são importantes para deixar o programa mais legível.
   Existe algumas maneiras de comentar o programa que será mostrado logo abaixo: </p>
<pre>
// comentario até o fim da linha
/* Multipla
* comentar linha
*/
/**
* javadoc multipla linha comentario
* @author alan Santos
*/
</pre>
<h2>Classes vs Arquivos</h2>
<p>Você pode colocar duas classes no mesmo arquivo. Quando fizer isso em mais de uma classe o arquivo
 somente é permitido ser público.</p>;
<pre>
public class Arvore{
private string nome;
}
class Arvore2{
}
</pre>
<h2>Escrevendo um método main</h2>
<p>O programa java inicia a execução com este <b>metodo main()</b>. Um <b>método main()</b> é o gateway entre o 
inicio de um processo java, que é gerenciado pelo <b>java virtual machine (JVM)</b>, e os códigos dos programas.
O <b>JVM</b> chama no sistema subjacente para alocar memória , tempo de CPU, acessar arquivos e mais.
O <b>método main()</b> nos permite ligar nosso código neste processo, mantendo-o vivo por tempo suficiente
para fazer o trabalho que codificamos.</p>
<pre>
public class Planta{
public static void main(String[] args){}
}
</pre>
<p>Este coúigo não é útil. Este não tem declarações nem instruções. Somente para ilustrar.<br>
   Para compilar execute este comando abaixo no terminal:</p>
<br>
<p><b>
$ javac Planta.java <br>
$ java Planta <br>
</b>
</p>
<br>
<h2>Executando argumentos no método main</h2>
<pre>

public class Planta{
public static void main(String[] args){
System.out.println(args[0]);
System.out.println(args[1]);
}
}
</pre>
<p> Digite este comando no terminal:</p>
<p><b>
$ javac Planta.java<br>
$ java Planta Hortela , Mastruz<br>
 <br>

//saida:  Hortela
          Mastruz
</b>
<p>
  <br>
<h2>Entendendo Pacotes, Declaracão e imports</h2>
<p>Java coloca classes em Pacotes (package "name package";).E quando necessitamos de classes que são predefinidas
 precisamos importá-las para dentro da nossa classe para que as classes funcionem. Nos casos abaixo estamos tentando
  usar a <b>Classe Random</b> para números aleatórios.</p>
<pre>
// sem import não funciona
public class ImportExample {
public static void main(String[] args) {
Random r = new Random(); // NÃO COMPILA
System.out.println(r.nextInt(10)); 
}
}
</pre> <br>
<pre>
import java.util.Random; // import nos conta onde encontrar o Random
public class ImportExample {
public static void main(String[] args) {
Random r = new Random(); 
System.out.println(r.nextInt(10));//imprime numero entre 0 e 9
}
}
</pre>
<h2>Wildcards(*) </h2>
<p>Usando wildcards(*) dentro das pastas que contém as classes você importa não somente a que você quer, mas
 também deixa disponível todas as outras.</p>
<pre>
import java.util.*; // importa java.util.Random além de outras coisas
public class ImportExample {
public static void main(String[] args) {
Random r = new Random();
System.out.println(r.nextInt(10));
}
}
</pre>
<h2>Imports redundantes</h2>
<p>Java lang é um pacote especial e é automaticamente importado, nela contém classe como <b>String</b> por exemplo.</p>
<pre>
 import java.lang.System; // desnecessario
 import java.lang.*;// desnecessario
 import java.util.Random;// necessario
 import java.util.*;// neste caso não é necessario pois já importou o Random acima
 public class ImportExample {
 public static void main(String[] args) {
 Random r = new Random();
 System.out.println(r.nextInt(10));
 }
 }
</pre>
<h2>Criar novo pacote</h2>
<p>Crie essas pastas <b>packagea</b> e <b>packageb</b> em seu diretorio com suas devidas classes <b>ClasseA</b> e <b>ClasseB</b>.</p>
<pre>
C:\seudiretorio\packagea\ClasseA.java
package packagea;
public class ClassA {
}
C:\seudiretorio\packageb\ClasseB.java
package packageb;
import packagea.ClasseA;
public class ClasseB {
public static void main(String[] args) {
ClassA a;
System.out.println("Got it");
}
}
</pre>
<p>Após criar as pastas(pacotes) e as classes, execute estes comandos no terminal:</p>
<pre>
$javac packagea/ClasseA.java packageb/ClassB.java 
$java packageb.ClasseB
Se a saída for <b>Go it</b> então funcionou bem!
</pre>
<h2>Criando Objetos</h2>
<p>Um objeto é uma instância da classe. Para criar uma instância de classe faz o seguinte:</p>
<p><b>ex: Randon r = new Random();</b></p>
<p>Onde o <b>r</b> será a referência que será utilizado para acessar o objeto em memória.</p>
<h2>Construtores</h2>
<p>Contrutores tem o mesmo nome da classe e não existe retorno</P>
<pre>
public class Folha {
public Folha() {
System.out.println("no construtor");
}
}
</pre>
<p>Construtor também serve para inicializar campos:</p>
<pre>
public class Fruta {
int numManga = 0;// inicializa na linha
String nome;
public Fruta() {
name = "Manga";// inicializa no constructor
}
}
</pre>
<h2>Lendo e escrevendo campos e Objetos</h2>
<p>É possivel ler e escrever variáveis de instância de dentro da chamada:</p>
<pre>
public class Baleia {
int numFilhote;// variavel de instancia
public static void main(String[] args) {
Baleia mae = new Baleia();
mae.numFilhote = 5; //set variable - Escrever na variavel conhecido como "set"
System.out.println(mae.numFilhote); //read variable - Ler a variavel conhecido como "get'
}
}
</pre>
<p>Voce pode ler e escrever campos na declaração..</p>
<pre>
public class Name {
String first = "Theodore";
String last = "Moose";
String full = first + last;
}
</pre>
<h2>Inicialização Ordenada</h2>
<p>Campos e blocos inicializadores de instância são executados na ordem em que aparecem o arquivo.
 O construtor é executado depois que todos os campos e blocos de inicialização de instância são executados.</p>
<pre>
public class Fruta {
private String name = "Manga";
{ 
System.out.println("Escrevendo no campo");
}
public Fruta() {
name = "Pera";
System.out.println("Escrevendo no construtor");
}
public static void main(String[] args) {
Fruta  fruta = new Fruta();
System.out.println(fruta.name); } }
</pre>
<p>Execuando este exemplo imprime isto:<br>
<b>->Escrevendo no campo<br>
->Escrevendo no construtor<br>
->Pera</b><br>
</p>
<h2>Distinguir entre Objeto Referência e Primitivos</h2>
<p>Aplicações java contem 2 tipos de dados: tipo primitivo e tipo referência.</p>
<h4>Tipos primitivos</h4>
<p>Java tem oito tipos de dados embutido que é referido como tipos primitivos de dados.</p>
<div>
  <table>
  <tr>
    <th>Palavra-chave</th>
    <th>Tipo</th>
     <th>Exemplo</th>
     <tr>
      <tr>
     <td> boolean</td>
     <td> true ou false</td>
     <td> true</td>
     
  </tr>
  <tr>
     <td> byte</td>
     <td> 8-bit valor integral</td>
     <td> 125</td>
     
  </tr>
  <tr>
     <td> short</td>
     <td> 16-bit valor integral</td>
     <td> 125</td>
     
  </tr>
  <tr>
     <td> int</td>
     <td> 32-bit valor integral</td>
     <td> 125</td>
     
  </tr>
  <tr>
     <td> long</td>
     <td> 64-bit valor integral</td>
     <td> 125</td>
     
  </tr>
  <tr>
     <td> float</td>
     <td> 32-bit valor integral</td>
     <td> 125.54f</td>
     
  </tr>
  <tr>
     <td> double</td>
     <td> 64-bit valor integral</td>
     <td> 125.555</td>
     
  </tr>
  <tr>
     <td> char</td>
     <td> 16-bit  valor Unicode </td>
     <td> 'a'</td>
     
  </tr>
</table>
</div>
<br>
<ol>
<li>float e double são usados com ponto flutuantes(decimal) valores</li> 
<li>Um float requer a letra <b>f</b> seguido do número.</li>
<li>byte, short, int e long são números usados sem casas decimais</li>
</ol>
<h4>Tipos referência</h4>
<p>Um tipo de referência refere-se a um objeto (uma instância de uma classe). Ao contrário dos 
tipos primitivos que contêm seus valores na memória onde a variável é alocada, referências não mantêm o valor
do objeto a que se referem. Em vez disso, uma referência "aponta" para um objeto armazenando o endereço  
da memória onde o objeto está localizado, um conceito referido como um ponteiro.</p>
<p>Referência do tipo <b>java.util.Date</b> e uma referência do tipo <b>String</b/>:
<br>
<br>
<b>
java.util.Date hoje;
<br>
String cumprimento;
</b>
</p>
<br>
<p>A variável <b>hoje</b> é uma referência do tipo <b>Date</b> e pode somente apontar para <b>Date</b> objeto.
 Assim como <b>cumprimento</b> só pode apontar para <b>String</b>.</p>
<ol>
<li>Uma referência pode ser atribuída a outro objeto do mesmo tipo.</li>
<li>Uma referência pode ser atribuída a um novo objeto usando a nova palavra-chave.</li>
</ol>
<br>
<p>
 <b>
hoje = new java.util.Date();
<br>
cumprimento = "Como está voCê?";
</b>
</p>
<p>Diferença chave é que tipos primitivos não podem ser adcionado valor nulo.</p>
<h2>Declarando e inicializando Variáveis</h2>
<pre>
<b>Declarando variáveis</b>
String zooName;
int numberAnimals;
<b>Inicializando variáveis</b>
String zooName = "The Best Zoo";
int numberAnimals = 100;
<b>Declarar e inicializar multiplas variáveis</b>
String s1, s2;
String s3 = "yes", s4 = "no";
</pre>
<h2>Identificadores</h2>
<p>As mesmas regras para identificadores se aplicam a qualquer coisa que você é livre para nomear, incluindo variáveis,
métodos, classes e campos.</p>
<p>Existem apenas três regras para lembrar de identificadores legais:</p>
<ul>
<li>O nome deve começar com uma letra ou o símbolo $ ou _.</li>
<li>Caracteres subseqüentes também podem ser números.</li>
<li>Você não pode usar o mesmo nome que é uma palavra reservada do Java. </li>
</ul>
<pre>
<b>Os exemplos a seguir são legais</b>
okidentifier
$OK2Identifier 
_alsoOK1d3ntifi3r
__SStillOkbutKnotsonice$ 
<b>Estes exemplos são ilegais:</b> 
3DPointClass // identificaores não pode inicalizr com numeros
hollywood@vine // @ não é uma letra, digito, $ ou _
*$coffee // * não é uma letra, digito, $ ou _
public // public  é uma palavra reservada
</pre>
<h2>Palavras reservadas</h2> 
<p>Você não pode usar o mesmo nome que uma palavra reservada do Java. Como você pode imaginar,
 uma palavra reservada é uma palavra-chave que o Java reservou para que você não tenha permissão para usá-la.
Lembre-se de que o Java faz distinção entre maiúsculas e minúsculas, portanto, 
é possível usar versões das palavras-chave que diferem apenas no caso.</p>
<pre>
abstract assert boolean break byte case catch 
char class const* continue default do double
else enum extends false final finally float for 
goto* if implements import instanceof int 
interface long native new null package private 
protected public return short static strictfp 
super switch synchronized this throw throws 
transient true try void volatile while
</pre>
<h2>Entendendo o padrão de inicialização das variáveis</h2>
<p>Variaveis Locais são definido dentro do método. Variáveis locais deve ser inicializada antes de ser utilizada.</p>
<pre>
 public int notValid() {
 int y = 10; 
 int x; 
 int reply = x + y; //NÃO COMPILA
 return reply;
 }
 public int valid() {
 int y = 10;
 int x; // x é declarada aqui
 x = 3; // e inicializado aqui
 int reply = x + y;
 return reply;
 }
</pre>
<h2>Instância e variáveis de classe</h2>
<p>As variáveis que não são locais são conhecidas como variável de instância ou variável de classes.
Variáveis de instância são chamadas de campos. Variaveis de classes são compartilhadas com múltiplos
objetos se carregar a palavra chave <b>static</b> antes dele.</p>
<pre>
Tipos de variaveis    Valor da inicalização padrão
boolean               false
byte,short,int,long   0(in the type’s bit-length)
float,double          0.0(in the type’s bit-length)
char                  '\u0000'(NUL)
</pre>
<h2>Entendendo a variável de Escopo</h2>
<p>Existem duas variáveis local neste método. <b>pedacoDeQueijo</b> é declarado no lado de dentro do método.
 E <b>fatiaDeQueijo</b> que é chamado de um método. Ambas as variáveis são ditas como tendo um escopo local para o método. 
 Isso significa que eles não podem ser usado fora do métodos, exemplo: </p>
<p> O escopo é delimitado pelo par de chaves{} no qual a instrução a ser chamada faz parte.<p>
<pre>
public void comerSeFome(boolean faminto) {
if (faminto) {
int pedacoDeQueijo = 1;
} // fatiaDeQueijo vai sair do escopo
System.out.println(fatiaDeQueijo);// Não Compila
}
</pre>
<p><i>Neste caso, <b>fatiaDeQueijo</b> não compila por está fora do escopo da declaração, seu parâmetro não foi declarado</i>.</p>
<h2>Ordenando elementos na classe</h2>
<ol>
<li>Declaração de pacote -> package abc;   -Primeira linha do arquivo</li>
<li>Declaração do import -> import java.util.*;   - Imediatamente depois do pacote</li>
<li>Declaração da classe-> public class  -Imediatamente depois do pacote</li>
<li>Declaração do campo-> int value; - Qualquer lugar dentro da classe</li>
<li>Declaração do metoo -> void method() - Qualquer lugar dentro da classe</li>
</ol>
<h2>Destruindo Objetos</h2>
<p>Java fornece coletores de lixo (garbage collection) automaticamente para procurar objetos que não necessita mais.
<b>Garbage Collections(coletor de lixo)</b> refere-se ao processo de liberar memória automaticamente no <b>heap</b> 
deletando objetos que está distante de ser alcançável no seu programa.</p>
<h2>finalize()</h2>
<p>Java permite que os objetos implementem um método chamado <b>finalize()</b> que possa ser chamado.
  Este método é chamado se o coletor de lixo tentar coletar o objeto.</p>
<pre>
public class Finalizer {
protected void finalize() {
System.out.println("Calling finalize");
} 
public static void main(String[] args) {
Finalizer f = new Finalizer();
} 
}
</pre>
<p>A razão é que o programa sai antes que haja qualquer necessidade de executar o coletor de lixo. 
  Enquanto <b>f</b> é elegível para coleta de lixo, Java tem coisas melhores para fazer do que coletar lixo constantemente.
  Você precisa saber que essa chamada <b>finalize()</b> pode ser executada zero ou uma vez.</p>
<h1>RESUMÃO</h1>
<p>
Você viu que as classes Java consistem em membros chamados campos e métodos. O objeto é uma instância de uma classe Java. 
Existem três estilos de comentário: um comentário de linha única (//), um comentário de múltiplas linhas (/ * * /) 
e um comentário de Javadoc (/ ** * /).</p><br>
<p>Java inicia a execução do programa com um método main().</p><br> 
<p>A assinatura mais comum para este método executado a partir da linha de comando é public static void main (String [] args).</p><br>
<p>Argumentos são passados ​​após o nome da classe, como em java NameOfClass firstArgument.
Argumentos são indexados começando com 0.<p/><br>
<p>O código Java é organizado em pastas chamadas pacotes.
Para fazer referência a classes em outros pacotes, você usa uma instrução de importação.</p><br> 
<p>Um caractere(*) que termina uma instrução de importação significa que você deseja importar todas as classes desse pacote. 
 Não inclui pacotes que estão dentro daquele.java.lang é um pacote especial que não precisa ser importado.<p><br>
<p>Construtores criam objetos Java. Um construtor é um método que corresponde ao nome da classe e
omitindo o tipo de retorno. Quando um objeto é instanciado, campos e blocos de código são
inicializado pela primeira vez. Então o construtor é executado.</p><br>
<p>Tipos primitivos são os blocos básicos de construção dos tipos Java. Eles são montados em
tipos de referência. Os tipos de referência podem ter métodos e serem designados como nulos.</p><br> 
<p>Declarar uma variável envolve declarar o tipo de dados e dar à variável um nome.
As variáveis ​​que representam campos em uma classe são automaticamente inicializadas para o valor “zero” ou nulo 
correspondente durante a instanciação de objetos. Variáveis ​​locais devem ser especificamente inicializado.</p><br>
<p> Identificadores podem conter letras, números, $ ou _. Identificadores podem não começar com
números.<p><br>
<p>Escopo refere-se àquela parte do código onde uma variável pode ser acessada. Há três
tipos de variáveis ​​em Java, dependendo de seu escopo: variáveis ​​de instância, variáveis ​​de classe e
variáveis ​​locais. Variáveis ​​de instância são os campos não estáticos da sua classe. Variáveis ​​de classe são
os campos estáticos dentro de uma classe. Variáveis ​​locais são declaradas dentro de um método.</p><br>
<p>Para alguns elementos de classe, a ordem é importante no arquivo. A declaração do pacote vem primeiro
se presente. Depois vem as declarações de importação, se presentes. Depois vem a declaração de classe.</p><br>
<p>Campos e métodos podem estar em qualquer ordem dentro da classe.</p><br>
<p>A coleta de lixo é responsável por remover objetos da memória quando eles podem
nunca mais ser usado novamente. Um objeto se torna elegível para coleta de lixo quando não há
mais referências a ele ou suas referências ficaram fora do escopo. O método finalize ()
será executado uma vez para cada objeto se / quando for o primeiro lixo coletado.</p><br>

<p><i>O código Java é orientado a objetos, o que significa que todo código é definido em classes. Modificadores de acesso
permite que classes encapsulem dados. Java é independente de plataforma, compilando para bytecode. Isto é
robusto e simples, não fornecendo ponteiros ou sobrecarga do operador. Finalmente, o Java é seguro
porque roda dentro de uma máquina virtual</i>.</p><br><br>

<h1>2-ENTENDENDO OPERADORES EM JAVA</h1>
<p>Um operador Java é um simbolo especial que pode ser aplicado para um conjunto de variáveis, valores, 
ou literais-referido como operando - e este retorna o resultado.</p>
<p>São três operadores acessíveis em java: unário, binário, ternário. Estes tipos de operadores podem ser aplicado
para uma, duas ou três operandos, respectivamente.</p>
<p> Os operadores Java não são necessariamente avaliados da ordem da esquerda para a direita. Por exemplo, 
a seguinte expressão Java é realmente avaliada da direita para a esquerda, considerando os operadores específicos envolvidos:</p>
<br>
<p>
<b>
int y = 2;
<br>
double x = 4 + 3 * --y;
</b>
<br>
</p>
<br>
<p>Neste exemplo, primeiro decrementa <b>y</b> para 1 e então multiplica o resultado do valor por 3 
e finalmente adciona 4. O valor final de <b>x</b> e <b>y</b> seria 7.0 ( fica 7.0 automaticamente por o tipo ser double ) e 1 respectivamente .</p>
<h2>Ordem de precedência do operador</h2>
<h4>Simbolos e exemplos de Operadores</h4>
<table>
  <tr>
    <th> Operadores</th>
    <th> Simbolos e Exemplos</th>
  </tr>
  <tr>
    <td>
      Pos-Unario
    </td>
    <td>
      expresao++, expressao--
    </td>
  </tr>
  <tr>
    <td>
      Pre-Unario
    </td>
    <td>
      ++expresao, --expressao
    </td>
  </tr>
  <tr>
    <td>
    Outros Operadores Unario
    </td>
    <td>
      +, -, !
    </td>
  </tr>
  <tr>
    <td>
      Multiplicação/Divisão/Modulos
    </td>
    <td>
      *, /, %
    </td>
  </tr>
  <tr>
    <td>
     Adição/Subtração 
    </td>
    <td>
     +, -
    </td>
  </tr>
  <tr>
    <td>
      Shift operators
    </td>
    <td>
     <<, >>, >>>
    </td>
  </tr>
  <tr>
    <td>
      Operadores relacional
    </td>
    <td>
      <, >, <=, >=, instanceof
    </td>
  </tr>
  <tr>
    <td>
     Iguadade/negação de igualdade
    </td>
    <td>
      ==, !=
    </td>
  </tr>
  <tr>
    <td>
      Operadores Lógicos
    </td>
    <td>
     &, ^, |
    </td>
  </tr>
  <tr>
    <td>
     Curto-circuito operadores lógicos
    </td>
    <td>
      &&, ||
    </td>
  </tr>
  <tr>
    <td>
    Ternario 
    </td>
    <td>
    expressao booleana ? expressao1 :expressao2
    </td>
  </tr>
  <tr>
    <td>
     Atribuição
    </td>
    <td>
      =, +=, -=, *=, /=, %=, &=, ^=, !=, <<=,>>=, >>>=
    </td>
  </tr>
</table>
<h2>Trabalhando com Operadores binários Aritimético</h2>
<p>Operadores binarios são comumente combinado em experssões complexas com mais do que duas variáveis, contudo, operador precedente
é muito importante em avaliar expressões.</p>
<p>Operadores Aritimetico inclui adição(+), subtração(-), multiplicação(*), divisão(/), e modulo(%).
 Eles também inclui o perador unario ++ e --. Os operadores(*, /, %) tem maior prioridade em relação ao operadores (+,-).</p>
<p>Isso significa quando você ver uma expressão assim:</p>
<br>
<p><b>int x = 3*5 + 2*5 -10;</b></p>
<br>
<p>Primeiro avalia 3*5 e 2*5 que reduz a expressão ficando assim:</p>
<br>
<p><b>
 int x = 15 + 10 - 8;
</b>
</p>
<br>
 <p>Então você avalia o termo da esquerda e atribui o valor a variável da direira resultando no valor de x = 17</p>
<p>Você pode mudar a ordem da operação adcionando parênteses ao redor da seção que será avaliada primeiro.</p>
<pre>

int x= 2 *((5+3) * 4-8)
int x= 2*(8*4-8);
int x= 2*(32-8);
int x= 2*24
int x = 48;
</pre>
<p>Todos dos operadores aritmético pode ser aplicado para qualquer Java primitivos, exceto <b>boolean</b> e <b>String</b>. 
  Aplicando operadores + e += pode ser aplicado em valores <b>String</b> .</p>
<h2>Entendendo a diferença entre divisão aritimética e modulos.</h2>
<p>Para valores inteiros, a divisão resulta no valor mínimo do inteiro mais próximo que cumpre a operação,
 enquanto o módulo é o valor restante da divisão.<p/>
<p>exemplo da saida no console:</p>
<pre>
System.out.print(9 / 3); // saida 3
System.out.print(9 % 3); // saida 0
System.out.print(10 / 3); // saida  3
System.out.print(10 % 3); // saida  1
System.out.print(11 / 3); // saida  3
System.out.print(11 % 3); // saida 2
System.out.print(12 / 3); // saida  4
System.out.print(12 % 3); // saida 0
</pre>
<h2>Promoção Numérica</h2>
<p>Se dois valores de tipos de dados diferentes. Java irá automaticamente promover um dos valores mais largos dos dois tipos de dados.</p>
<p> Qual é o tipo de dados x * y?</p><br>
<p><b>
int x = 1;
<br>
long y = 33;
</b>
</p>
<p><i>1. O valor será promovido para long, pois long é mais largo do que int.</i></p>
<br>
<p>2. Se um dos valores é integral e o outro é ponto flutuante, Java ira automatiamente promover o valor integral
 ao tipo de dados valores ponto flutuante .</p>
<p>Qual é o tipo de dados x + y?</p>
<br>
<p><b>
int x = 40;
<br>
float y = 2.1f;
<p></b>
  <br>
<p>3.Pequenos tipos de dados nomeadamente <b>byte, short, e char</b>, são primeiros promovidos para <b>int</b>,
 em qualquer momento que eles estiverem usando um operador aritimético binario java, mesmo se nenhum dos operandos for int.</p>
<p>Qual é o tipo de dados x / y?</p>
<br>
<p><b>
short x = 10;
<br>
short y = 3;
</b>
</p>
<p><i>Antes da operacão <b>x</b> e <b>y</b> serão pomovidos para <b>int</b>, resultando na saida do tipo <b>int</b></i>.</p><br>
<p>4. Após toda a promoção ter ocorrido e os operandos terem o mesmo tipo de dados,
 o valor resultante terá o mesmo tipo de dados que seus operandos promovidos.</p>
<p>Qual é o tipo de dados x * y / z?</p>
<br>
<p>
<b>
short x = 14;
<br>
float y = 13;
<br>
double z = 30;
<br>
</b>
</p>
<p><i>Neste caso, primeiro <b>x</b> seria automaticamente promovido para <b>int</b>, porque este é um <b>short</b> 
  e está sendo usado em uma operação binária aritimética.</i></p>
<p><i>O valor <b>x</b> promovido será automaticamene promovido para <b>float</b> então este pode ser multiplicado com <b>y</b></i>.</p>
<p><i>O resultado de <b>x*y</b> seria então automaticamente promovida para <b>double</b>, assim então este pode ser dividido com <b>z</b>, resultando em um valor <b>double</b></i>.</p>
<h2>Trabalhando com Operadores Unário</h2>
<p>Por definição um operador unário é um que requer exatamente um operando, ou variável, para função.</p>
<pre>
Operador Unario  Descricao
+                Indica um número está positivo
-                Indica um número literal está negativo ou uma expressão negativa.
++               Incrementa um valor por 1
--               Decrementa um valor por 1
!                Inverte um valor lógica Boleana
</pre>
<h2>Complemento Lógico e Negação de Operadores</h2>
<p>O operador de complemento logico, <b>!</b>, inverte o valor de uma expressão booleana. 
Por exemplo se o valor é verdadeiro(true) será convertido para falso, e vice versa.</p>
<pre>
boolean x = false;
System.out.println(x); // false 
x=!x;
System.out.println(x); // verdadeiro (true)
</pre>
<p>Da mesma forma, o operador negação, <b>-</b>, reverte o sinal de uma expressão numérica.</p>
<pre>
double x = 1.21;
System.out.println(x); // 1.21
 x = -x;
System.out.println(x); // -1.21
 x = -x;
 System.out.println(x); // 1.21
</pre>
<br>
<p> Nenhuma das linhas abaixo irão compilar:</p>
<br>
<p><b>
int x = !5; // NÃO COMPILA, JAVA NÃO PODE PERFORMAR UMA INVERSÃO LOGICA DE UMA VALOR NUMERICO
<br>
boolean y = -true; // NÃO COMPILA, NÃO PODE NEGAR NUMERICAMENTE UM VALOR BOOLEANO.
<br>
boolean z = !0; // NÃO COMPILA  NÃO PODE ATRIBUIR UM INTEIRO PARA UMA VARIAVEL BOOLEANA.
</b>
</p>
<br>
<h2>Operadores Incremento e Decremento</h2>
<p>Operadores Incremento e Decremento ++ e -- respectivamente pode ser aplicado a operandos numéricos 
e ter a ordem ou precedência mais alta, em comparação aos operadores binários.</p>
<p>Eles são aplicado primeiro para uma expressão.</p>
<p>Se o operador é colocado antes do operando, refere como operador pre-incremento e o operador pre-decremento.
 Então o operador é aplicado primeiro e o valor retornado é o novo valor da expressão.</p>
<p>Se o operaor é colocado depois do operando refere como o operador pos-incremento e o operador pos-decremento, 
neste caso o valor original da expressão é retornado com operador aplicado depois do valor retornado.</p>
<p>Trecho ilustrando estas distinções.</p>
<pre>
int counter = 0;
System.out.println(counter); // Saída 0
System.out.println(++counter); // Saída 1
System.out.println(counter); // Saída 1
System.out.println(counter--); // Saída 1
System.out.println(counter); // Saída 0
</pre>
<p>
O primeiro operador pre-incremento atualiza o valor para <b>counter</b> e a saida do novo valor 1.
 O próximo operador pos-decremente também atualiza o valor de <b>counter</b> mas antes do valor de saida o decremento ocorre.</p>
<p>Como você ler ese código?</p>
<pre>
int x = 3;
int y = ++x * 5 / x-- + --x;
System.out.println("x is " + x);
System.out.println("y is " + y);
</pre>
<h2>Entedendo o código</h2>
<p>int y= 4*5/ x-- + --x; //<i> para x é atribuido o valor 4</i><br>
Proximo <b>x</b> é decrementado, mas o original valor de 4 é usado na expressão:<br>
int y = 4*5 / 4 + --x // <i>para x é atribuido o valor de 3</i><br>
</p>
<br>
<p>A atribuição final de <b>x</b> reduz para o valor 2, e este é um operador pre-incremento, que o valor é retornado assim:</p>
<p>
int y = 4 * 5 / 4 +2; // para x é atribuido o valor 2<br><br>
Finalmente, nos avaliamos a multiplicação e divisão da esquerda pra direita, por causa da precedência dos operadores.<br>
o resultado imprimido é:<br>
x é 2;<br>
y é 7;<br>
</p>
<br>
<h2>Usando Operadores Binário Adicional.</h2>
<p>Um operador atribuição  é um operador binario que modifica, ou atribui a variável na mão-esquerda do lado do operador,
 com o resultado do valor na mão-direita do lado da equação.</p>
<br>
<p><b>int x =1</b></p>
<p><i>Esta declaração atribui para x o valor de 1</i></p>
<br>
<pre>
int x = 1.0; // NÃO COMPILA
short y = 1921222; // NÃO COMPILE
int z = 9f; //  NÃO COMPILA
long t = 192301398193810323; // NÃO COMPILA
</pre>
<ol>
  <li>A primeira declaração não compila por que você está tentando atribuir um <b>double</b> 1.0 para um valor inteiro.</li>
<li>Quando adiciona o <b>.0</b> automaticamente Java atribui ao tipo de dados <b>double</b> .</li>
<li>A segunda declaração não compila porque o valor literal 1921222 esta fora do alcance de <b>short</b> e o compilador detecta isto.</li>
<li>A terceira declaração não compila porque ao adicionar <b>f</b> no final do número o compilador trata esta instrução como valor ponto flutuante.</li>
<li>Finalmente, o último não compila porque java interpreta o literal como <b>int</b> e nota que o valor é mais extenso do que o <b>int</b> permite.</li>
<li>O literal necessitaria adicionar <b>L</b> no final do número para ser considerado long.</li>
 </ol>
<h2>Casting em Valores Primitivos</h2>
<p>Casting primitivos é requrido em qualquer momento que você esta indo de um tipo de dados numérico mais extenso para tipo de dados numérico de menor extensão, ou convertendo de um número ponto flutuante para um número inteiro.</p>
<pre>
int x = (int) 1.0;
short y = (short) 1921222 // armazenado como 20678 
int z =(int)9l;
long t = 19230139810323L;
</pre>
<p>As expressões do exemplo anterior agora compilam, embora haja um custo. O segundo valor, 1.921.222,
 é muito grande para ser armazenado como um <b>short</b>, portanto ocorre um excesso numérico e ele se torna 20.678.</p> 
<p>Overflow é quando um número é tão grande que não cabe mais dentro do tipo de dados, então o sistema “envolve”
 o próximo valor mais baixo e conta a partir daí. Há também um underflow análogo, quando o número é muito baixo 
 para caber no tipo de dados.</p>
<h2>Operadores de Atribuição Composta</h2>
<pre>
int x = 2, z=3;
x= x*z;  // operador de atribuição simples
x *= z; // operador atribuição composta 
</pre>
<p>O lado-esquerdo do operador composto pode ser somente aplicado para variável que já está definido e não 
 pode ser usada para declarar uma nova variável. Se <b>x</b> não estivesse definido a expressão <b>x*=z</b> não compilaria.<p>
<p>o operador composto é útil para abreviar e também pode nos salvar de fazer um <b>cast</b> explicito. Exemplo:</p>
<pre>
long x = 10;
int y = 5
y= y*x; // não compila
y=(int)y*x; //cast explicito 
</pre>
<p>Esta última linha poderia ser ficado com um <b>cast</b> explicito para (int), mas existe uma melhor maneira atribuindo operador composto.</p>
<pre>
long x = 10
int y = 5
y *=x; // compila
</pre>
<h2> Operadores Relacional</h2>
<p>Operadores relacional compara duas expressões e retorna um valor booleano.</p>
<br>
<p>
< menor do que <br>
<= menor igual<br>
> maior do que<br>
>= maior igual <br>
</p>
<br>
<pre>
int x = 10, y = 20, z = 10;
System.out.println(x < y); // Saida true(verdadeiro)
System.out.println(x <= y); // Saida true
System.out.println(x >= z); // Saida true
System.out.println(x > z); // Saída false
</pre>
<p><b>a instanceof b</b> - <i>Verdadeiro se a referência para qual <b>a</b> aponta é uma instância de
uma classe, subclasse ou classe que implementa uma determinada interface, como mencionado em <b>b</b></i>.</p>
<p>O operador <b>instanceof</b>, é útil para determinar se um objeto arbitrário é um membro de uma classe particular ou interface.</p>
<h2>Operadores Lógicos</h2>
<p>Os operadores lógicos, (&), (|), e (^), pode ser aplicado para ambos tipos de dados , numérico e booleano.</p>
<p>Quando eles são alocados para um tipo de dados boolean, eles são referidos como operadores lógicos. 
  Alternativamente, quando eles são aplicados para um tipo de dados numéricos, eles são referidos como operadores bitwise (bit a bit).</p>
<h3>Logica da tabela verdade para & | e ^</h3>
<pre>
    <b>x & y</b>                                                
     (E)       
 -----------  y=   Verdade(true) y=false  
  x=Verdade |      Verdade       false
  x=false   |      false         false             
    <b>x | y</b>                                                
 (OU Inclusivo)       
 -----------   y=   Verdade    y=false  
  x=Verdade |       Verdade     Verdade
  x=false   |       Verdade     false
    <b>x ^ y</b>                                                
 (OU Exclusivo)       
 -----------  y=   Verdade     y=false  
  x=Verdade |      false       Verdade
  x=false   |      Verdade     false
</pre>
<ul>
<li> E (&) é somente verdade se ambos operandos são verdadeiro</li>
<li> OU Inclusivo é somente falso se ambos operandos são falso</li>
<li> OU Exclusivo é somente verdade se os operandos são diferentes</li>
</ul>
<p> Operadores && e || são conhecidos como operadores curto-circuito. Eles são quase idênticos
 aos operadores lógico & e | , respectivamente espera que o lado-direito da expressão nunca 
 pode ser avaliado se o resultado final pode ser determinado pela expressão lógica do lado-esquerdo.</p>
 <br>
<p><b>boolean x = true || (y<4);</b></p>
<br>
<p>Referindo a tabela verdade, o valor de <b>x</b> pode ser somente <b>false</b> se ambos os lados da expressão forem falso.</p>
<pre>
if(x != null && x.getValue() < 5){// expressão ok
// fazer algo
}if(x != null & x.getValue() < 5){//Lança uma excessão se x for nulo
// fazer algo
}
</pre>
<h2>Operadores de Igualdade</h2>
<p>Vamos iniciar com  o básico, o operador <b>igual ==</b> e operador <b>não igual !=</b>. O operador relacional 
  eles comparam dois operandos e retorna um valor booleano se as expressões ou valores são iguais, ou não iguais.</p>
<p>Os operadores de igualdade são usados nestes cenarios:</p>
<ol>
<li>Comparar dois tipos numéricos primitivos. Se o valor numérico são de diferentes tipos de dados,
 os valores são automaticamente promovido. Por exemplo <b>5==5.00</b> retorna <b>true</b> desde que o lado-esquerdo
  for promovido para um <b>double</b>.</li>
<li> Comparar dois valores booleanos. Comparar dois objetos, incluindo <b>null</b> e valores <b>String</b>.</li>
</ol>
<p>A comparação por igualdade são limitado por este três casos, então você não pode misturar tipos correspondentes:</p>
<pre>
EX:1
boolean x = true == 3; // NÃO COMPILA
boolean y = false != "Giraffe"; // NÃO COMPILA
boolean z = 3 == "Kangaroo"; // NÃO COMPILA
EX:2
boolean y = false;
boolean x = (y = true);
System.out.println(x); // SAIDA true
EX:3
File x = new File("myFile.txt");
File y = new File("myFile.txt");
File z = x;
System.out.println(x == y); // SAIDA false
System.out.println(x == z); // SAIDA true
</pre>
<h2>DECLARAÇÃO if-then</h2>
<p>Frequentemente, somente queremos executar um bloco de código sob certa circunstância.
 A declaração <b>if-then</b>, permite nossa aplicação executar um bloco de código particular
 se e somente se a expressão avaliada for verdadeira em tempo de execução.</p>
 <br>
<p>
<b>Estrutura:</b><br>
if(expressão booleana){ <i>//As chaves requere para blocos de multipla declaração, é opcional para uma única declaração</i>.<br>
  // ramo se verdade<br>
}<br>
</p>
<br>
<p>Exemplo, imagine ter uma função que usa a hora do dia, um valor inteiro de 0 a 23 para mostrar uma mensagem ao usuario.</p>
<br>
<p>
<b>
if(horaDoDia < 11)<br>
System.out.println("Bom dia");<br>
</b>
</p>
<br>
<p>Se a hora do dia for menor que 11 então a messagem será mostrada.</p>
<br>
<p>
  <b>
if(horaDodia < 11) {<br>
System.out.println("Bom dia");<br>
contSaudacao++;<br>
}
</b>
<br>
</p>
<br>
<p>Aqui é incrementado algum valor, <b>contSaudacao</b>, cada vez que saudação é imprimido na tela.</p>
<h2>Declaração If-then-else</h2>
<p>Estrutura:</p>
<pre>
if(expressão booleana){
  // ramifica se verdade
} else{  //declaração else é opcional
  //ramifica se falso
}
if(horaDoDia < 11){
  System.out.println("Bom dia!");
}else{
  System.out.pintln("Boa tarde!");
}
</pre>
<p>Agora nosso código está realmente ramificando entre uma das duas opções possíveis, com a avaliação
 booleana acontecendo apenas uma vez.</p>
<p> O operador <b>else</b> usa uma instrução ou bloco de instrução, da mesma maneira que a declaração <b>if</b>.
 Dessa maneira, podemos acrescentar instruções <b>if-then</b> adicionais a um bloco <b>else</b> para chegar
 a um exemplo mais refinado:</p>
<pre>
if(horaDoDia < 11) {
System.out.println("Bom dia!");
} else if(horaDoDia < 15) {
System.out.println("Boa tarde!");
} else {
System.out.println("Boa Noite");
}
</pre>
<h2>Operador Ternário</h2>
<p>É um tipo de operador que leva três operando desta forma:</p>
<br>
<p><b>expressaoBoolena ? expressao1 : expressao2</b></p>
<br>
<p>O primeiro operando deve ser uma expressão booleana, e a segunda e terceira pode ser qualquer expressão que retorna um valor.
O operador ternário é relmente um condensada forma de um <b>if-then-else</b> declaração que returna um value. Por exemplo:</p> 
<pre>
int y=10;
final int x;
if(y > 5){
  x=2*y;
}else{
  x=3*y;
}
</pre>
<p> Compare o trecho de código anterior com a seguinte trecho de código ternário equivalente:</p>
<br>
<p>
  <b>
int y = 10;<br>
int x = (y>5) ? (2*y) : (3*y);<br>
</b>
</p>
<br>
<p>Note que este é frequentemente útil para readapidabilidde , adcionando parênteses ao redor do expressão em operação ternário.</p>
<br>
<p>
  <b>
System.out.println((y>5) ? 21 : "zebra");<br>
int animal = (y>91) ? 9 : "Horse": // Não compila<br>
</b>
</p>
<br>
<p>Ambas expressão similar avaliada e valores booleano retornam um <b>int</b> e uma <b>String</b>, apesar somente a primeira linha irá compilar.</p>
<h2>A declaração switch</h2>
<p>É uma complexa estrutura de tomada de decisão no qual o único valor é acessado e o fluxo é redirecionado 
para o ramo correspondente, conhecido como declaração <b>case</b>.</p>
<p>Se nenhuma declaração de <b>case</b> for encontrada que corresponda ao valor, uma declaração padrão opcional será chamada.</p> 
<p>Se tal opção <b>default</b> não estiver disponível, toda a instrução do <b>switch</b> será ignorada.</p>
<h2>Estrutura da declaração switch</h2>
<pre>
switch(TestVariavel) {// --> Inicando com a chavae(requere)
case ExpressaoConstante1;
// Ramo para case1:
break; //opcional
...
case ExpressaoConstante2;
//Ramo paraa case2;
break;//opcional
...
default: // Opcional default , este pode aparecer em qualquer lugar dentro da declaracao switch
//Ramo para default
} //-->Finalizando chaves(requere)
</pre>
<p>Tipos de dados suportados pela declaracão switch:</p>
<pre>
.int e Integer
.byte e byte
.short e Short
.char e Character
.String
.enum values
</pre>
<h2>Valores constantes de tempo de compilação</h2>
<p>Os valores em cada declaração <b>case</b> deve ser valores constantes em tempo de compilação do mesmo
 tipo de dados como do valor do <b>switch</b>.</p>
<p>Isto significa que você pode usar somente literais, enum constantes, ou variveis constantes <b>final</b> do mesmo tipo de dados</p>
<p>Por constante <b>final</b>, queremos dizer que a variável deve ser marcado com o modificador <b>final</b> e inicializado com um
valor literal na mesma expressão na qual ele é declarado.</p>
<pre>
final int a = 2;
final int b = 5;
final int c = 7;
switch (a) {
case b + c: // não dá erro em tempo de compilãção porque é avaliado
//todas as variaveis são finais. então isto é compilação em tempo constante
System.out.println(b + c);
break;
}
</pre>
<p>Exemplo usando dias da semana com 0 para domingo, 1 para Segunda assim por diante:</p>
<pre>
int diasDaSemana = 5;
switch(diaDaSemana) {
default:
System.out.println("Quarta-Feira");
break;
case 0:
System.out.println("Domingo");
break;
case 6:
System.out.println("Sabado");
break;
}
</pre>
<p>Com o valor do <b>diaDaSemana</b> de 5, este codigo sairá:</p><br>
<p><b>-->Quarta-Feira</b><p><br>
<p>A primeira coisa que pode notar é que existe um <b>break</b> no fim da declaração de cada seção <b>case </b> e <b>default</b>.
É o <b>break</b> que termina a declaração <b>switch</b> e retorna o controle de fluxo para encerrar a declaração.</p><br>
<p><b>Outro Exemplo:</b></p>
<pre>
int diaDaSemana = 5;
switch(diaDaSemana) {
case 0:
System.out.println("Domingo");
default:
System.out.println("DiaDaSemana");
case 6:
System.out.println("Sabado");
break;
}
</pre>
<p>Este código se parece muito com o exemplo anterior, exceto que duas das instruções de <b>break</b>
foi removido e a ordem foi alterada.<p>
<p> Isto significa que para o valor dado de <b>diaDaSemana</b>, 5, o código irá pular 
para o bloco <b>default</b> e então irá executar todos os procedimentos e declarações <b>case</b> 
em ordem até encontrar uma declaração ou terminar a estrutura.</p>
<p>Saida:</p>
<p><b>-> DiaDaSemana<br> 
      -> Sabado</b><br></p>

<h2>A DECLARAÇÃO while</h2>
<p>Uma estrutura de controle de repeticao, que nós referimos como loop, executa uma declaração de códigos múltiplas vezes sucessivamente.</p>
<h2>A estrutura da declaração while</h2>
<pre>
while(expressaoBooleana){ 
//Chaves é requerido para blocos de multiplas declarações 
//Chaves é opcional para uma unica declaração.
//Corpo
} //fecha chaves
</pre>
<p>Um <b>while loop</b> é similar a uma declaração <b>if-then</b> este é composto de uma expressão booleana e a declaração, ou bloco de declarações.
Durante a execução, a expressão booleana é avaliada antes de cada iteração do loop e finaliza se a avaliação retornar falso.</p>
<p>É importante notar que o loop pode terminar antes da primeira avaliação da expressão booleana. 
  Dessa maneira o bloco de declaração pode nunca ser executado.</p>
<pre>
int espacoNaBarriga = 5;
public void comeQueijo(int pedacosDequeijo) {
while (pedacosDequeijo > 0 && espacoNaBarriga > 0) { 
pedacoDequeijo--;
espacoNaBarriga--;
}
System.out.println(pedacosDeQueijo+" Saindo pedacos de queijo");
}
</pre>
<p>Este método leva uma quantidade de comida, neste caso queijo, e continua até que o rato não
 tenha espaço em sua barriga ou não haja comida para comer.</p>
<p>Com cada iteração do loop, o rato "come um pedaço de queijo e perde espaço em sua barriga.
Usando uma declaração booleana composta, você assegura que o <b>while loop</b> possa terminar para qualquer uma das condições. </p>
<h2>A DECLARAÇÃO do..while</h2>
<p>Ao contrario de <b>while loop</b>, <b>do-while loop</b> garante que a declaração ou bloco seja executada pelo menos uma vez.</p>
<h2>A estrutura da declaração do..while</h2>
<pre>
//palavra chave--->
 do{ 
//chaves opcional para unica declaração e requerida para multiplas declarações
        //Corpo
 } while(expressaoBooleana); 
 //Requer Ponto e virgula
//requer parenteses
//While palavra chave
</pre>
<p>A diferença primaria entre a estrutura de um <b>do-while loop</b> a um <b>while loop</b> é que <b>do-while loop,</b> 
propositadamente ordena a declaração ou o bloco de instruções antes da expressão condicional, 
a fim de reforçar que a declaração será executada antes que a expressão seja avaliada</p>
<pre>
<b>Exemplo:</b> 
int x = 0;
do {
x++;
} while(false);
System.out.println(x); // Outputs 1
} 
<b>Exemplo2:</b>
Este whileloop:
while(x > 10) {
x--;
}
e este do-whileloop:
if(x > 10) {
do {
x--;
} while(x > 10);
}
<b>Exemplo3:</b>
if(x > 10) {
do {
x--;
} while(x > 10);
} else {
x++;
}
</pre>
<h2>A DECLARAÇÃO for</h2>
<p>Um <b>loop for</b> básico tem a mesma expressão booleana condicional e declaração, ou bloco de declaração, como outros loops:
 um bloco de inialização e uma declaração de atualização.</p>
<h4>A estrutura básica da declaração for</h4>
<br>
<p>
  <b>
for(inicializacao; expressaobooleana; declaracaoAtualizacao){<br>
  //Corpo<br>
}</b>
</p>
<br>
<ol>
<li> Executa a declaração inicialização</li>
<li> ExpressaoBooleana é verdadeiro(true) continue, senão finaliza loop</li>
<li> Executa o Corpo</li>
<li>Executa a declaracoAtualizacao</li>
<li>Retorna ao passo 2</li>
</ol>
<p>Note que cada seção é separada por ponto e virgula. A inicialização e seção de atualização pode conter múltiplas declarações, 
  sepradas por virgulas.</p>
<p>Este é um loop básico que imprime numeros de 0 a 9;</p>
<pre>
for(int i = 0; i < 10; i++) {
System.out.print(i + " ");
}
//Saida -> 0 1 2 3 4 5 6 7 8 9 
</pre>
<h2>Criando um loop infinito</h2>
<pre>
for( ; ; ) {
System.out.println("Hello World");
}
// Este Loop compila e executa sem problemas
</pre>
<h2>Adcionar Múltiplos termos para declaração for</h2> 
<pre>
int x = 0;
for(long y = 0, z = 4; x < 5 && y < 10; x++, y++) {
System.out.print(y + " ");
}
System.out.print(x);
}
</pre>
<p>Este código demonstra três variações do <b>loop for</b>.
Primeiro, você pode declarar uma variável, como <b>x</b> neste exemplo, antes de iniciar o loop e usá-lo após a conclusão. 
Segundo, seu bloco de inicialização, expressão booleana e instruções de atualização pode incluir variáveis ​​extras que podem não se referenciar. 
Por exemplo, <b>z</b> é definido no bloco de inicialização e nunca é usado. Finalmente, a atualização pode modificar várias variáveis.</p>
<p>Este codigo quando executar a saida é:</p>
<p><b>//0 1 2 3 4</b></p>
<h2>A Declaraçao For-each</h2>
<p>Esta declaração é especialmente desenhada para iteragir sobre <b>arrays</b> e objetos <b>colletion</b>.</p> 
<h2>Estrutura de uma declaração for-each</h2>
<pre>
// Requer, dois pontos :
for(tipodedados1 instancia : collection){//Abre chaves
    // |->membro da coleção do tipodedados1
   //Corpo   
|  ->iterage com colecao de objetos
 Chaves requerido para blocos de multiplas declarações,
  opcional para uma unica declaração
}//fecha Chaves
</pre>

<p>A declaração <b>loop for-each</b> é composta de uma seção de inicialização e um objeto para ser iterado.
 O lado-direito da declaração <b>loop for-each</b> deve ser construido um <b>array</b> ou um objeto em que implemente 
 a classe <b>java.lang.Iterable</b>, que inclui mais do framework <b>Java Collections.</b></p>
 <p>O lado-esquerdo do <b>loop for-each</b> deve incluir uma declaração para uma instância de uma variável, cujo tipo corresponde ao tipo de um membro do
<b>array</b> ou <b>collection </b> no lado direito da instrução.</p>
<p>Em cada iteração do loop, a variável nomeada no lado-esquerdo da declaração é atribuido um novo valor do <b>array</b>
 ou <b>collection</b> no lado-direito da declaração.</p>
<p>Vamos ver alguns exemplos:</p>
<p>Qual será a saida deste codigo.</p>
<pre>
final Sring[] nomes = new String[3];
nomes[0] = " Lisa";
nomes[1] ="Catia";
nomes[2]= "Alan";
for(String nome : names){
System.out.println(nome + ", ");
<b>A saida será: Lisa , Catia, Alan</b>
</pre>
<p>Qual será a saida deste codigo?</p>
<pre>
java.util.List<String> values = new java.util.ArrayList<String>();
values.add("Lisa");
values.add("Catia");
values.add("Alan");
for(String value : values) {
System.out.print(value + ", ");
}
Este codigo imprime os mesmos valores: 
Lisa, Catia, Alan,
</pre>
<h2>LOOPS ANINHADOS</h2>
<p>Loops que pode conter outros loops.</p>
<pre>
<b>Exemplo:</b>
int[][] meuComplexoArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}};
for(int[] meuSimplesArray : meuComplexoArray) {
for(int i=0; i < meuSimplesArray.length; i++) {
System.out.print(meuSimplesArray[i]+"\t");
}
System.out.println();
}
</pre>
<p>Note que está intecionalmente misturado um <b>for</b> e <b>for-each </b> neste exemplo. O loop exterior executa um total de três vezes.</p>
<p>Cada tempo que executa o loop exterior, o loop interior é executado 4 vezes.</p>
<pre>
A saida é essa:
5 2 1 3
3 9 8 9
5 7 12 7
</pre>
<h2>Adcionar Rótulos opcionais</h2>
<p>Um rotulo(Label) é um ponteiro opcional para o cabeçário da declaração que permite o fluxo da aplicação pular para ele ou brecar dele.
Esta é unica palavra prosseguida por dois pontos(:).</p>
<pre>
<b> Colocando rotulo no exemplo anterior: </b>
int[][] meuComplexoArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}};
OUTER_LOOP: for(int[] meuSimplesArray : meuComplexoArray) {
INNER_LOOP: for(int i=0; i < meuSimplesArray.length; i++) {
System.out.print(meuSimplesArray[i]+"\t");
}
System.out.println();
}
</pre>
<h2>A DECLARAÇÃO <b>break</b></h2>
<p>Esta declaração transfere a saída do fluxo de controle para o encerramento da declaração.</p>
<h2>A estrutura da declaração break</h2>
<pre>
//Referencia opcional para o cabeçalho do loop
rotuloOpcional: while(expressaoBooleana){
//Corpo DoisPontos(Requerido se o rotuloOpcional está presente)
//Algum lugar no loop
break rotuloOpcional; // Ponto e virgula(requerido)
//|-> break palvra chave
}
</pre>
<p>Note que a declaração <b>break</b> pode ter um parâmetro de rotulo opcional.
Sem um rótulo como parâmetro, a declaração final terminará o loop interno mais próximo que está atualmente em processo de execução.</p>
<h2>A DECLARACÃO continue</h2>
<p>Uma declaracao que faz com que o fluxo termine a execução do loop atual</p>
<h2>A estrutura da declaração continue</h2>
<pre>
//Referencia opcional para o cabeçalho do loop
rotuloOpcional: while(expressaoBoolena){
//Corpo DoisPontos(Requerido se o rotuloOpcional está presente)
//Algum lugar no loop
continue rotuloOpcional; // Ponto e virgula(requerido)
//|-> continue palvra chave
}
</pre>
<p>Você pode notar que a sintax da declaração <b>continue</b> é um espelho da declaração <b>break</b>.
  Enquanto a declaração <b>break</b> transfere o controle para o encerramento da declaração, 
a declaração <b>continue</b> transfere o controle para a expressão booleana que determina se o loop deve continuar.</p>

<h1>RESUMÃO</h1>

<p>Foi  visto agora uma ampla variedade de tópicos, incluindo  operadores Java,
com instruções de fluxo de controle.</p><br> 
<p>É importante entender como usar todos os operadores Java necessários
para as declarações, foi abordado  tipos de estruturas de controle de
 tomada de decisão , incluindo <b>if-then, if-then-else</b>, e a declaração <b>switch</b>, bem como
estruturas de controle de repetição, incluindo <b>for</b>, </b>for-each</b>, <b>while</b> e <b>do-while</b>.</p> <br>
<p>A maioria dessas estruturas requer a avaliação de uma expressão booleana particular, seja para
decisões de ramificação ou uma vez por repetição. A declaração <b>switch</b> é a única que suporta uma variedade de tipos de dados, 
incluindo variáveis ​​de <b>string</b>.</p></br>
<p>Com uma declaração para cada, você não precisa escrever explicitamente uma expressão booleana, uma vez que
o compilador os constrói implicitamente.</p><br>
<p>Concluímos discutindo as opções avançadas de controle e como o fluxo pode ser
aprimorada por meio de loops aninhados, com informações de interrupção e instruções permanentes. </p>
<br>
  <br>
<p>Parabéns por ter chegado até aqui, agora é hora de brincar com os códigos que estão no repositório pronto pra ser usado.
  Os códigos correspondem a todo este conteúdo. Divirtam-se!</p><br>

<p style="text-align:center;"><a href="https://github.com/namanis/namanis.github.io/tree/master/javacodigos" target="_blank" >ACESSE O REPOSITÓRIO GITHUB</a></p>
</div>
</body>
</html>

